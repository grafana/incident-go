// Code generated by oto; DO NOT EDIT.

// Package incident is a Go client library which makes it easy to
// interact with the Grafana Incident JSON/HTTP RPC API.
package incident

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// UserAgent is the User-Agent string used when making HTTP requests.
var UserAgent = "incident-go/v1.92.2"

// Client is used to access services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// BeforeRequest is an optional hook that gives you the opportunity
	// to inspect or modify the request before it is made.
	// Useful for adding auth headers, for example.
	// By default, it will add the Authorization header using the serviceAccountToken.
	BeforeRequest func(r *http.Request) error
	// Debug writes a line of debug log output.
	// No-op by default.
	Debug func(s string)

	// stubmode causes all the methods to return example data
	// without actually hitting the API. Useful for testing.
	stubmode bool
}

// NewClient makes a new Client.
// The remoteHost should be "https://your-stack.grafana.net/api/plugins/grafana-incident-app/resources/api/v1"
// with `your-stack.grafana.net` pointing to your instance.
// The serviceAccountToken can be obtained from the Configuration via the web app
// (For more information, see https://grafana.com/docs/grafana-cloud/incident/api/rpc/auth/).
func NewClient(remoteHost, serviceAccountToken string) *Client {
	c := &Client{
		RemoteHost: remoteHost,
		Debug:      func(s string) { /* no-op by default */ },
		HTTPClient: &http.Client{Timeout: 60 * time.Second},
		stubmode:   false,
		BeforeRequest: func(r *http.Request) error {
			// add the Authorization header
			r.Header.Set("Authorization", "Bearer "+serviceAccountToken)
			return nil
		},
	}
	return c
}

// NewTestClient makes a new test Client that always returns the same
// data.
func NewTestClient() *Client {
	c := &Client{
		Debug:    func(s string) { /* no-op by default */ },
		stubmode: true,
	}
	return c
}

// ActivityItem describes an event that occurred related to an Incident.
type ActivityItem struct {

	// The unique identifier of the ActivityItem.
	ActivityItemID string `json:"activityItemID"`

	// IncidentID is the unique identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// User is the person who caused the ActivityItem.
	User UserPreview `json:"user"`

	// SubjectUser is the person who was affected by the ActivityItem (not the person
	// who caused it).
	SubjectUser UserPreview `json:"subjectUser"`

	// CreatedTime is the time when the ActivityItem was created. The string value
	// format should follow RFC 3339.
	CreatedTime string `json:"createdTime"`

	// EventTime is the time when the event occurred. It is configurable by the user.
	// The string value format should follow RFC 3339.
	EventTime string `json:"eventTime"`

	// ActivityKind is the type of activity this item represents.
	ActivityKind string `json:"activityKind"`

	// Body is a human readable description of the ActivityItem.
	Body string `json:"body"`

	// URL is an url related with this activity
	URL string `json:"url"`

	// Tags contains a list of tags associated with this activity.
	Tags []string `json:"tags"`

	// Immutable indicates if the activity is immutable.
	Immutable bool `json:"immutable"`

	// FieldValues is an object of field values associated with the ActivityItem.
	// The structure is determined by the ActivityKind.
	FieldValues map[string]interface{} `json:"fieldValues"`

	// Attachments is a list of files attached to this item.
	Attachments []Attachment `json:"attachments"`

	// Relevance is the preferred relevance of the activity item. if set to 'automatic'
	// (the default), the relevance will be guessed automatically.
	Relevance string `json:"relevance"`
}

// ActivityQuery is the response from the QueryActivity method.
type ActivityQuery struct {

	// IncidentID is the unique identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Limit is the number of Incidents to return.
	Limit int `json:"limit"`

	// Tag is the tag to filter by.
	Tag string `json:"tag"`

	// OrderDirection is the direction to order the results.
	OrderDirection string `json:"orderDirection"`

	// ActivityKind filters by a list of allowed ActivityKind's.
	ActivityKind []string `json:"activityKind"`
}

// AddActivityRequest is the request for the AddActivity method.
type AddActivityRequest struct {

	// IncidentID is the unique identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// ActivityKind is the type of activity this item represents.
	ActivityKind string `json:"activityKind"`

	// Body is a human readable description of the ActivityItem. URLs mentioned will be
	// parsed and attached as context.
	Body string `json:"body"`

	// EventTime is the time when the event occurred. If empty, the current time is
	// used. The string value format should follow RFC 3339.
	EventTime string `json:"eventTime"`
}

// AddActivityResponse is the response from the AddActivity method.
type AddActivityResponse struct {

	// ActivityItem is the newly created ActivityItem.
	ActivityItem ActivityItem `json:"activityItem"`
}

// AddFieldRequest is the request struct for api AddField method.
type AddFieldRequest struct {

	// Field is the field to add.
	Field CustomMetadataField `json:"field"`
}

// AddFieldResponse is the response from the AddField method.
type AddFieldResponse struct {

	// Field is the field that was added.
	Field CustomMetadataField `json:"field"`
}

// AddFieldSelectOptionRequest is the request struct for AddFieldSelectOption
// method.
type AddFieldSelectOptionRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`

	// FieldSelectOption is the new field select option.
	FieldSelectOption CustomMetadataFieldSelectOption `json:"fieldSelectOption"`
}

// AddFieldSelectOptionResponse is the response from the AddFieldSelectOption
// method.
type AddFieldSelectOptionResponse struct {

	// FieldSelectOptionUUID is the UUID of the field select option that was added.
	FieldSelectOptionUUID string `json:"fieldSelectOptionUUID"`
}

// AddLabelKeyRequest is the request for the AddLabelKey method.
type AddLabelKeyRequest struct {

	// Key is the label key.
	Key string `json:"key"`

	// Description is a short explanation of the label.
	Description string `json:"description"`

	// Color is the CSS hex color of the label. Labels show up in both light and dark
	// modes, and this should be taken into consideration when selecting a color.
	ColorHex string `json:"colorHex"`
}

// AddLabelKeyResponse is the response for the AddLabelKey method.
type AddLabelKeyResponse struct {

	// Field is the field that was added.
	Field CustomMetadataField `json:"field"`
}

// AddLabelRequest is the request for the AddLabel method.
type AddLabelRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Label is the new label of the Incident.
	Label IncidentLabel `json:"label"`
}

// AddLabelResponse is the response for the AddLabel method.
type AddLabelResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// AddLabelValueRequest is the request for the AddLabelValue method.
type AddLabelValueRequest struct {

	// Key is the label key.
	Key string `json:"key"`

	// Value is the label value.
	Value string `json:"value"`

	// Description is a short explanation of the label value.
	Description string `json:"description"`

	// Color is the CSS hex color of the label value. Labels show up in both light and
	// dark modes, and this should be taken into consideration when selecting a color.
	ColorHex string `json:"colorHex"`
}

// AddLabelValueResponse is the response for the AddLabelValue method.
type AddLabelValueResponse struct {

	// Field is the field that was updated.
	Field CustomMetadataField `json:"field"`
}

// AddTaskRequest is the request for the AddTask method.
type AddTaskRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// Text is the todo item.
	Text string `json:"text"`

	// AssignToUserId is the user the task wil be assigned to
	AssignToUserId string `json:"assignToUserID"`
}

// AddTaskResponse is the response from the AddTask method.
type AddTaskResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// ArchiveFieldRequest is the request struct for api ArchiveField method.
type ArchiveFieldRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`
}

// ArchiveFieldResponse is the response from the ArchiveField method.
type ArchiveFieldResponse struct {
}

// ArchiveRoleRequest is the request to archive a role.
type ArchiveRoleRequest struct {

	// Role to be archived to the organization
	RoleID int `json:"roleID"`
}

// ArchiveRoleResponse is the response to archive a role.
type ArchiveRoleResponse struct {
}

// AssignLabelByUUIDRequest is the request for the AssignLabelByUUID method.
type AssignLabelByUUIDRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// KeyUUID is the label key uuid.
	KeyUUID string `json:"keyUUID"`

	// ValueUUID is the UUID of the label value.
	ValueUUID string `json:"valueUUID"`
}

// AssignLabelByUUIDResponse is the response from the AssignLabelByUUID method.
type AssignLabelByUUIDResponse struct {

	// Labels is a list of labels
	Labels []IncidentKeyValueLabel `json:"labels"`
}

// AssignLabelRequest is the request for the AssignLabel method.
type AssignLabelRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Key is the label key.
	Key string `json:"key"`

	// Value is the value of the label.
	Value string `json:"value"`
}

// AssignLabelResponse is the response from the AssignLabel method.
type AssignLabelResponse struct {

	// Labels is a list of labels
	Labels []IncidentKeyValueLabel `json:"labels"`
}

// AssignRoleRequest is the request for the AssignRole method.
type AssignRoleRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// UserID is the identifier of the person to assign the role to.
	UserID string `json:"userID"`

	// Role is the role of this person.
	Role string `json:"role"`
}

// AssignRoleResponse is the response for the AssignRole method.
type AssignRoleResponse struct {

	// Incident is the Incident that was just updated.
	Incident Incident `json:"incident"`

	// DidChange indicates if the role was changed or not. If the role was already
	// assigned, this will be false.
	DidChange bool `json:"didChange"`
}

// Relation between a User and a Role inside the incident
type Assignment struct {

	// User is the person who holds this role.
	User UserPreview `json:"user"`

	// Role is the role string.
	Role Role `json:"role"`

	// RoleID is the identifier of the role.
	RoleID int `json:"roleID"`
}

// AssignmentPreview describes a person assigned to an incident without the Role
// object.
type AssignmentPreview struct {

	// User is the person who holds this role.
	User UserPreview `json:"user"`

	// RoleID is the identifier of the role.
	RoleID int `json:"roleID"`
}

// Attachment is a file attached to something.
type Attachment struct {

	// AttachmentID is the unique ID of this attachment.
	AttachmentID string `json:"attachmentID"`

	// AttachedByUserID is the ID of the user who attached this.
	AttachedByUserID string `json:"attachedByUserID"`

	// SourceURL is the URL of the file.
	SourceURL string `json:"sourceURL"`

	// UseSourceURL is true if the file should be downloaded from the source URL.
	UseSourceURL bool `json:"useSourceURL"`

	// Path is the full path of the file.
	Path string `json:"path"`

	// UploadTime is the time the file was uploaded.
	UploadTime string `json:"uploadTime"`

	// DeletedTime is the time the file was deleted. Empty string means the file hasn't
	// been deleted.
	DeletedTime string `json:"deletedTime"`

	// ContentType is the type of the file.
	ContentType string `json:"contentType"`

	// FileType is the type of file.
	FileType string `json:"fileType"`

	// Ext is the file extension.
	Ext string `json:"ext"`

	// ContentLength is the ContentLength of the file in bytes.
	ContentLength int64 `json:"contentLength"`

	// DisplayType is how the file will be displayed.
	DisplayType string `json:"displayType"`

	// DownloadURL for download
	DownloadURL string `json:"downloadURL"`

	// HasThumbnail is true if the file has a thumbnail.
	HasThumbnail bool `json:"hasThumbnail"`

	// ThumbnailURL for previews
	ThumbnailURL string `json:"thumbnailURL"`

	// SHA512 is the hash of the file contents.
	SHA512 string `json:"sHA512"`

	// AttachmentErr is a string describing an error that occurred while processing the
	// attachment.
	AttachmentErr string `json:"attachmentErr"`
}

// CreateIncidentRequest is the request for the CreateIncident method.
type CreateIncidentRequest struct {

	// Title is the headline title of the Incident. Shorter the better, but should
	// contain enough information to be able to identify and refer to this issue.
	Title string `json:"title"`

	// Severity expresses how bad the Incident is.
	Severity string `json:"severity"`

	// Labels are the labels associated with the Incident. Only the Label string is
	// processed, the other fields are ignored.
	Labels []IncidentLabel `json:"labels"`

	// RoomPrefix is the prefix that will be used to create the Incident room.
	RoomPrefix string `json:"roomPrefix"`

	// IsDrill indicates if the Incident is a drill or not. Incidents that are drills
	// do not show up in the dashboards, and may behave subtly differently in other
	// ways too. For example, during drills, more help might be offered to users.
	IsDrill bool `json:"isDrill"`

	// Status is the starting status of the Incident. Use "resolved" to open a
	// retrospective incident.
	Status string `json:"status"`

	// AttachCaption is the title of associated URL.
	AttachCaption string `json:"attachCaption"`

	// AttachURLis the associated URL.
	AttachURL string `json:"attachURL"`
}

// CreateIncidentResponse is the response for the CreateIncident method.
type CreateIncidentResponse struct {

	// Incident is the Incident that was created.
	Incident Incident `json:"incident"`
}

// CreateRoleRequest is the request to create a role.
type CreateRoleRequest struct {

	// Role to be created to the organization
	Role Role `json:"role"`
}

// CreateRoleResponse is the response to create a role.
type CreateRoleResponse struct {

	// Role is the newly created role.
	Role Role `json:"role"`
}

// Cursor describes the position in a result set. It is passed back into the same
// API to get the next page of results.
type Cursor struct {

	// NextValue is the start position of the next set of results. The implementation
	// may change, so clients should not rely on this value.
	NextValue string `json:"nextValue"`

	// HasMore indicates whether there are more results or not. If HasMore is true,
	// you can make the same request again (except using this Cursor instead) to get
	// the next page of results.
	HasMore bool `json:"hasMore"`
}

// CustomMetadataField is a custom metadata field.
type CustomMetadataField struct {

	// UUID is the UUID of the field.
	UUID string `json:"uuid"`

	// Name is the name of the field.
	Name string `json:"name"`

	// Slug is the slug of the field. Used for searching and referencing the field as a
	// metric.
	Slug string `json:"slug"`

	// Color is the field color.
	Color string `json:"color"`

	// Icon is the field icon.
	Icon string `json:"icon"`

	// Description is the description of the field.
	Description string `json:"description"`

	// Type is the type of the field.
	Type string `json:"type"`

	// Required is whether this field is required.
	Required bool `json:"required"`

	// Immutable indicates if the field can by modified by the user.
	Immutable bool `json:"immutable"`

	// DomainName is scope for which the field is valid/used.
	DomainName string `json:"domainName"`

	// SelectOptions is the list of select options for the field. Only used for select
	// fields.
	Selectoptions []CustomMetadataFieldSelectOption `json:"selectoptions"`

	// Source indicates the origin of this field (eg. incident, gops-labels, github,
	// etc)
	Source string `json:"source"`

	// ExternalID, if defined, stores the ID of this field in a third-party service
	// (eg. gops-label id)
	ExternalID string `json:"externalID"`

	// Archived is whether this field is archived. Archived fields are not allowed to
	// be used in the new incidents. But the historical data is still kept.
	Archived bool `json:"archived"`
}

// CustomMetadataFieldSelectOption is a select option for a select field.
type CustomMetadataFieldSelectOption struct {

	// UUID is the UUID of the option.
	UUID string `json:"uuid"`

	// Value is the value of the select option.
	Value string `json:"value"`

	// Label is the label of the select option.
	Label string `json:"label"`

	// Color is the color of the select option.
	Color string `json:"color"`

	// Icon is the icon of the select option.
	Icon string `json:"icon"`

	// Description is the textual description of the option.
	Description string `json:"description"`

	// Source indicates the origin of this option (eg. incident, gops-labels, github,
	// etc)
	Source string `json:"source"`

	// ExternalID, if defined, stores the ID of this option in a third-party service
	// (eg. gops-label id)
	ExternalID string `json:"externalID"`
}

// CustomMetadataFieldValue is a custom metadata field value.
type CustomMetadataFieldValue struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`

	// Value is the json encoded value of the field.
	Value string `json:"value"`
}

// DeleteFieldRequest is the request struct for api DeleteField method.
type DeleteFieldRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`
}

// DeleteFieldResponse is the response from the DeleteField method.
type DeleteFieldResponse struct {
}

// DeleteFieldSelectOptionRequest is the request struct for DeleteFieldSelectOption
// method.
type DeleteFieldSelectOptionRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`

	// SelectOptionUUID is the UUID of the field select option to delete.
	SelectOptionUUID string `json:"selectOptionUUID"`
}

// DeleteFieldSelectOptionResponse is the response from the DeleteFieldSelectOption
// method.
type DeleteFieldSelectOptionResponse struct {
}

// DeleteRoleRequest is the request to delete a role.
type DeleteRoleRequest struct {

	// Role to be deleted to the organization
	RoleID int `json:"roleID"`
}

// DeleteRoleResponse is the response to delete a role.
type DeleteRoleResponse struct {
}

// DeleteTaskRequest is the request for the DeleteTask method.
type DeleteTaskRequest struct {

	// IncidentID is the ID of the Incident.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the task.
	TaskID string `json:"taskID"`
}

// DeleteTaskResponse is the response from the DeleteTask method.
type DeleteTaskResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// DisableHookRequest is the request for the DisableHook method.
type DisableHookRequest struct {

	// IntegrationID is the identifier of the installed integration.
	IntegrationID string `json:"integrationID"`

	// EnabledHookID is the identifier of the hook to disable.
	EnabledHookID string `json:"enabledHookID"`
}

// DisableHookResponse is the response for the DisableHook method.
type DisableHookResponse struct {
}

// EnableHookRequest is the request for the EnableHook method.
type EnableHookRequest struct {

	// IntegrationID is the identifier of the installed integration.
	IntegrationID string `json:"integrationID"`

	// HookID is the identifier of the hook to enable.
	HookID string `json:"hookID"`

	// EventName is the name of event to wire the hook up to. The hook will be called
	// when this event is fired.
	EventName string `json:"eventName"`

	// HookConfig is the configuration values to use when enabling the hook.
	HookConfig HookConfig `json:"hookConfig"`

	// IncidentFilter is the filter that determines if a hook with the 'incidentFilter'
	// event will be triggered.
	IncidentFilter string `json:"incidentFilter"`

	// Sensitive is true if the hook run should be triggered when the incident is
	// private. Ensures that hooks are not triggered for private incidents by default.
	Sensitive bool `json:"sensitive"`
}

// EnableHookResponse is the response for the EnableHook method.
type EnableHookResponse struct {

	// EnabledHookID is the identifier of the enabled hook. This is distinct from the
	// HookID.
	EnabledHookID string `json:"enabledHookID"`
}

// Field represents a key/value pair, with additional metadata. Fields are used to
// represent dynamic data structures.
type Field struct {

	// Key is the name of the field.
	Key string `json:"key"`

	// Type describes acceptable data for Value.
	Type string `json:"type"`

	// Description is the description of the field.
	Description string `json:"description"`

	// Value is the value of the field when running an action.
	Value string `json:"value"`

	// Secret is a marker that the field contains secret data and should not be visible
	// to users.
	Secret bool `json:"secret"`

	// Checked is true if the bool field has been checked.
	Checked bool `json:"checked"`

	// Hidden indicates that a field should not be shown in the UI. It is not secret,
	// just noisy, so hidden and out of the way.
	Hidden bool `json:"hidden"`
}

// FieldValue represents a record with a field and its value.
type FieldValue struct {

	// Field is the field definition.
	Field CustomMetadataField `json:"field"`

	// Value is the json encoded value of the field to record. If empty, the field
	// value will be set unset.
	Value string `json:"value"`
}

// GetFieldRequest is the request struct for api GetField method.
type GetFieldRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`
}

// GetFieldResponse is the response from the GetField method.
type GetFieldResponse struct {

	// Field is the requested field.
	Field CustomMetadataField `json:"field"`
}

// GetFieldValuesRequest is the request struct for the GetFieldValues method.
type GetFieldValuesRequest struct {

	// TargetKind is the kind of the target to record the field value for.
	TargetKind string `json:"targetKind"`

	// TargetID is the ID of the target to record the field value for.
	TargetID string `json:"targetID"`

	// DomainName, if provided, will filter the results to the specified domain.
	DomainName string `json:"domainName"`
}

// GetFieldValuesResponse is the response struct from the GetFieldValues method.
type GetFieldValuesResponse struct {

	// FieldValues is a list of field->value pairs.
	FieldValues []FieldValue `json:"fieldValues"`
}

// GetFieldsRequest is the request struct for api GetFields method.
type GetFieldsRequest struct {

	// DomainName, if provided, will filter the results to the specified domain.
	DomainName string `json:"domainName"`
}

// GetFieldsResponse is the response from the GetFields method.
type GetFieldsResponse struct {

	// Fields is the list of fields.
	Fields []CustomMetadataField `json:"fields"`
}

// GetHomescreenVersionRequest is the request for the GetHomescreenVersion method.
type GetHomescreenVersionRequest struct {
}

// GetHomescreenVersionResponse is the response for the GetHomescreenVersion
// method.
type GetHomescreenVersionResponse struct {

	// Version is the refresh value of the home screen. A higher value than last time
	// indicates that the home screen should be refreshed.
	Version int `json:"version"`
}

// GetHookRunsRequest is the request for the GetHookRuns method.
type GetHookRunsRequest struct {

	// IncidentID is the identifier of the incident to get hook runs for.
	IncidentID string `json:"incidentID"`
}

// GetHookRunsResponse is the response for the GetHookRuns method.
type GetHookRunsResponse struct {

	// HookRuns is a list of HookRuns for this Incident.
	HookRuns []HookRun `json:"hookRuns"`
}

// GetIncidentMembershipRequest is the request for the GetIncidentMembership
// method.
type GetIncidentMembershipRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`
}

// GetIncidentMembershipResponse is the response for the GetIncidentMembership
// method.
type GetIncidentMembershipResponse struct {

	// IncidentMembership is the list of people involved in an incident
	Assignments []Assignment `json:"assignments"`
}

// GetIncidentRequest is the request for the GetIncident method.
type GetIncidentRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`
}

// GetIncidentResponse is the response for the GetIncident method.
type GetIncidentResponse struct {

	// Incident is the Incident.
	Incident Incident `json:"incident"`
}

// GetIncidentVersionRequest is the request for the GetIncidentVersion method.
type GetIncidentVersionRequest struct {

	// IncidentID is the identifier of the Incident. A higher value than last time
	// indicates that the dashboard should be refreshed.
	IncidentID string `json:"incidentID"`
}

// GetIncidentVersionResponse is the response for the GetIncidentVersion method.
type GetIncidentVersionResponse struct {

	// Version is the refresh value of the Incident.
	Version int `json:"version"`
}

// GetLabelsRequest is the request for the GetLabels method.
type GetLabelsRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`
}

// GetLabelsResponse is the response from the GetLabels method.
type GetLabelsResponse struct {

	// Labels is a list of labels
	Labels []IncidentKeyValueLabel `json:"labels"`
}

// GetRolesRequest is the request to get all roles.
type GetRolesRequest struct {
}

// GetRolesResponse is the response to get all roles.
type GetRolesResponse struct {

	// Roles is the list of roles.
	Roles []Role `json:"roles"`
}

// GetUserRequest is the request for GetUser.
type GetUserRequest struct {

	// UserID is the user ID to find the user for. All ids are in the format
	// "provider:user-id" which allows you to refer to users from different providers.
	// "grafana-incident:<id>" is preferred, but all are accepted.
	UserID string `json:"userID"`
}

// GetUserResponse contains the information about a user.
type GetUserResponse struct {

	// User is the user
	User User `json:"user"`
}

// HookConfig holds configuration fields for a Hook.
type HookConfig struct {

	// Fields is a list of hook specific key/value pairs.
	Fields []Field `json:"fields"`
}

// HookMetadata contains metadata about the Run and Update of a Hook.
type HookMetadata struct {

	// Title is a title that relates to this Hook's run.
	Title string `json:"title"`

	// Explanation is a brief description about what action was taken.
	Explanation string `json:"explanation"`

	// URL is an optional URL to a place users can go for more information.
	URL string `json:"url"`
}

// HookRun describes the result of executing a Hook.
type HookRun struct {

	// IntegrationID is the ID of the installed Integration that the Hook belongs to.
	IntegrationID string `json:"integrationID"`

	// HookID is the ID of the Hook that was run.
	HookID string `json:"hookID"`

	// EnabledHookID is the ID of the enabled hook instance.
	EnabledHookID string `json:"enabledHookID"`

	// LastRun is the time the hook was last run.
	LastRun string `json:"lastRun"`

	// LastUpdate is the time the hook was last updated.
	LastUpdate string `json:"lastUpdate"`

	// Metadata holds Hook specific key/value pairs.
	Metadata HookMetadata `json:"metadata"`

	// EventName is the name of the event that triggered the Hook to run.
	EventName string `json:"eventName"`

	// EventKind gives more detail about the type of event.
	EventKind string `json:"eventKind"`

	// UpdateStatus is the status of the Hook update.
	UpdateStatus string `json:"updateStatus"`

	// UpdateError is an error string to show the end-user for when UpdateStatus is
	// "failed".
	UpdateError string `json:"updateError"`

	// Status is the status of the Hook run.
	Status string `json:"status"`
}

// Incident is a single incident.
type Incident struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// Severity expresses how bad the Incident is.
	Severity string `json:"severity"`

	// Labels is a list of strings associated with this Incident.
	Labels []IncidentLabel `json:"labels"`

	// IsDrill indicates if the Incident is a drill or not. Incidents that are drills
	// do not show up in the dashboards, and may behave subtly differently in other
	// ways too. For example, during drills, more help might be offered to users.
	IsDrill bool `json:"isDrill"`

	// CreatedTime is when the Incident was created. The string value format should
	// follow RFC 3339.
	CreatedTime string `json:"createdTime"`

	// ModifiedTime is when the Incident was last modified. The string value format
	// should follow RFC 3339.
	ModifiedTime string `json:"modifiedTime"`

	// CreatedByUser is the UserPreview that created the Incident.
	CreatedByUser UserPreview `json:"createdByUser"`

	// ClosedTime is when the Incident was closed. The string value format should
	// follow RFC 3339.
	ClosedTime string `json:"closedTime"`

	// DurationSeconds is the number of seconds this Incident was (or is) open for.
	DurationSeconds int `json:"durationSeconds"`

	// Status is the current status of the Incident.
	Status string `json:"status"`

	// Title is the high level description of the Incident.
	Title string `json:"title"`

	// OverviewURL is the URL to the overview page for the Incident.
	OverviewURL string `json:"overviewURL"`

	// Assignments describes the individuals involved in the Incident.
	IncidentMembership IncidentMembership `json:"incidentMembership"`

	// TaskList is the list of tasks associated with the Incident.
	TaskList TaskList `json:"taskList"`

	// Summary is as short recap of the Incident.
	Summary string `json:"summary"`

	// HeroImagePath is the path to the hero image for this Incident.
	HeroImagePath string `json:"heroImagePath"`

	// IncidentStart is when the Incident began. The string value format should follow
	// RFC 3339.
	IncidentStart string `json:"incidentStart"`

	// IncidentEnd is when the Incident ended. The string value format should follow
	// RFC 3339.
	IncidentEnd string `json:"incidentEnd"`
}

// IncidentKeyValueLabel is a key:value label associated with an Incident.
type IncidentKeyValueLabel struct {

	// Key is the label key.
	Key string `json:"key"`

	// KeyUUID is the UUID of the label key.
	KeyUUID string `json:"keyUUID"`

	// ValueUUID is the UUID of the label value.
	ValueUUID string `json:"valueUUID"`

	// Value is the value of the label.
	Value string `json:"value"`

	// Description is a short explanation of the label.
	Description string `json:"description"`

	// Color is the CSS hex color of the label. Labels show up in both light and dark
	// modes, and this should be taken into consideration when selecting a color.
	ColorHex string `json:"colorHex"`
}

// IncidentLabel is a label associated with an Incident.
type IncidentLabel struct {

	// Key is the label key. If not provided, we'll default to 'tags'.
	Key string `json:"key"`

	// Label is the text of the label.
	Label string `json:"label"`

	// Description is a short explanation of the label.
	Description string `json:"description"`

	// Color is the CSS hex color of the label. Labels show up in both light and dark
	// modes, and this should be taken into consideration when selecting a color.
	ColorHex string `json:"colorHex"`
}

// IncidentMembership represents a list of people involved in an Incident.
type IncidentMembership struct {

	// List of all assignments done for that incident
	Assignments []Assignment `json:"assignments"`

	// Total of assignments including hidden roles in the incident
	TotalAssignments int `json:"totalAssignments"`

	// Total of participants in the incident excluding the assigned roles
	TotalParticipants int `json:"totalParticipants"`
}

// IncidentMembershipPreview is a summary of the people involved in an Incident.
type IncidentMembershipPreview struct {

	// ImportantAssignments is a list of all assignments done for that incident that
	// are marked as important.
	ImportantAssignments []AssignmentPreview `json:"importantAssignments"`

	// Total of assignments including hidden roles in the incident
	TotalAssignments int `json:"totalAssignments"`

	// Total of hidden roles (like observers) related with that incident
	TotalParticipants int `json:"totalParticipants"`
}

// IncidentPreview is a minimal preview of a full Incident (omitting structured
// children) meant for lightweight listings or getting basic metadata.
type IncidentPreview struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// Severity expresses how bad the incident is.
	SeverityID string `json:"severityID"`

	// SeverityLabel is the label of the severity.
	SeverityLabel string `json:"severityLabel"`

	// IncidentType indicates the kind of incident to create.
	IncidentType string `json:"incidentType"`

	// Labels is a list of strings associated with this Incident.
	Labels []IncidentLabel `json:"labels"`

	// IsDrill indicates if the incident is a drill or not. Incidents that are drills
	// do not show up in the dashboards, and may behave subtly differently in other
	// ways too. For example, during drills, more help might be offered to users.
	IsDrill bool `json:"isDrill"`

	// CreatedTime is when the Incident was created. The string value format should
	// follow RFC 3339.
	CreatedTime string `json:"createdTime"`

	// ModifiedTime is when the Incident was last modified. The string value format
	// should follow RFC 3339.
	ModifiedTime string `json:"modifiedTime"`

	// ClosedTime is when the Incident was closed. The string value format should
	// follow RFC 3339.
	ClosedTime string `json:"closedTime"`

	// CreatedByUser is the UserPreview that created the Incident.
	CreatedByUser UserPreview `json:"createdByUser"`

	// Title is the high level description of the Incident.
	Title string `json:"title"`

	// Description is a brief description of the Incident.
	Description string `json:"description"`

	// Summary is as short recap of the incident.
	Summary string `json:"summary"`

	// HeroImagePath is the path to the hero image for this Incident.
	HeroImagePath string `json:"heroImagePath"`

	// Status is the current status of the Incident.
	Status string `json:"status"`

	// Slug is a URL friendly path segment for the Incident.
	Slug string `json:"slug"`

	// IncidentStart is when the Incident began. The string value format should follow
	// RFC 3339.
	IncidentStart string `json:"incidentStart"`

	// IncidentEnd is when the Incident ended. The string value format should follow
	// RFC 3339.
	IncidentEnd string `json:"incidentEnd"`

	// FieldValues is the list of fields associated with the Incident and their values.
	FieldValues []CustomMetadataFieldValue `json:"fieldValues"`

	// IncidentMembershipPreview is a summary of the people involved in the Incident.
	IncidentMembershipPreview IncidentMembershipPreview `json:"incidentMembershipPreview"`

	// Version is the times that the incident has been updated
	Version int `json:"version"`
}

// IncidentPreviewsQuery describes the query to make.
type IncidentPreviewsQuery struct {

	// Limit is the number of Incidents to return.
	Limit int `json:"limit"`

	// OrderDirection is the direction to order the results.
	OrderDirection string `json:"orderDirection"`

	// OrderField is the field on which to order the results. If empty, `createdTime`
	// will be used.
	OrderField string `json:"orderField"`

	// QueryString is the query string to search for. If provided, the query will be
	// filtered by the query string and the other query parameters will be ignored.
	QueryString string `json:"queryString"`
}

// IncidentsQuery is the query for the QueryIncidentsRequest.
type IncidentsQuery struct {

	// Limit is the number of Incidents to return.
	Limit int `json:"limit"`

	// IncludeStatuses is a list of statuses to include. Only Incidents with the listed
	// statuses will be returned.
	IncludeStatuses []string `json:"includeStatuses"`

	// ExcludeStatuses is a list of statuses to exclude. All Incidents that do not
	// match any of these values will be returned.
	ExcludeStatuses []string `json:"excludeStatuses"`

	// IncidentLabels is a list of labels to include. An empty list will not filter by
	// labels.
	IncidentLabels []string `json:"incidentLabels"`

	// DateFrom if is not empty would filter by the Incidents created since that date
	// (time.RFC3339)
	DateFrom string `json:"dateFrom"`

	// DateTo if is not empty would filter by incidents created before that date
	// (time.RFC3339)
	DateTo string `json:"dateTo"`

	// OnlyDrills if is not empty filters by whether an incident is a drill or not.
	OnlyDrills bool `json:"onlyDrills"`

	// OrderDirection is the direction to order the results.
	OrderDirection string `json:"orderDirection"`

	// Severity is a list of statuses to include. Only Incidents with the listed
	// statuses will be returned.
	Severity string `json:"severity"`

	// QueryString is the query string to search for. If provided, the query will be
	// filtered by the query string and the other query parameters will be ignored.
	QueryString string `json:"queryString"`
}

// IncomingWebhookResponse is the response sent back to the webhook caller when an
// incoming webhook has been received.
type IncomingWebhookResponse struct {

	// Incident is the newly declared incident. Only included if the incoming webhook
	// has the include=incident URL parameter.
	Incident *Incident `json:"incident"`

	// ProcessingErrors is a list of errors that occurred while processing the webhook.
	// If there are items in this list it does not mean the incident wasn't created.
	// But you should check to make sure everything was successfully processed before
	// shipping to production.
	ProcessingErrors []string `json:"processingErrors"`
}

// OutgoingWebhookPayload represents the webhook HTTP POST body and contains
// metadata for the webhook.
type OutgoingWebhookPayload struct {

	// Version of this structure, following semantic versioning.
	Version string `json:"version"`

	// ID of event.
	ID string `json:"id"`

	// Source is a URI that identifies the context in which an event happened.
	Source string `json:"source"`

	// Time that event was generated (RFC 3339).
	Time string `json:"time"`

	// Event describes the (namespaced) event
	Event string `json:"event"`

	// Incident is the data payload, contains details about the data that was changed.
	Incident *Incident `json:"incident"`
}

// QueryActivityRequest is the request for the QueryActivity method.
type QueryActivityRequest struct {

	// Query describes the query to make.
	Query ActivityQuery `json:"query"`

	// Cursor is used to page through results. Empty for the first page. For subsequent
	// pages, use previously returned Cursor values.
	Cursor Cursor `json:"cursor"`
}

// QueryActivityResponse is the response from the QueryActivity method.
type QueryActivityResponse struct {

	// ActivityItems is the list of items.
	ActivityItems []ActivityItem `json:"activityItems"`

	// Query is the query that was used to generate the response.
	Query ActivityQuery `json:"query"`

	// Cursor is used to page through results. Empty for the first page. For subsequent
	// pages, use previously returned Cursor values.
	Cursor Cursor `json:"cursor"`
}

// QueryIncidentPreviews is the request for the QueryIncidentPreviews method.
type QueryIncidentPreviewsRequest struct {

	// Query describes the query to make.
	Query IncidentPreviewsQuery `json:"query"`

	// Cursor is used to page through results. Empty for the first page. For subsequent
	// pages, use previously returned Cursor values.
	Cursor Cursor `json:"cursor"`

	// IncludeCustomFieldValues if true will include custom field values in the
	// response.
	IncludeCustomFieldValues bool `json:"includeCustomFieldValues"`

	// IncludeMembershipPreview if true will include membership previews in the
	// response.
	IncludeMembershipPreview bool `json:"includeMembershipPreview"`
}

// QueryIncidentPreviewsResponse is the response for the QueryIncidentPreviews
// method.
type QueryIncidentPreviewsResponse struct {

	// IncidentPreviews is a list of Incident Previews.
	IncidentPreviews []IncidentPreview `json:"incidentPreviews"`

	// Query is the query that was used to generate this response.
	Query IncidentPreviewsQuery `json:"query"`

	// Cursor should be passed back to get the next page of results.
	Cursor Cursor `json:"cursor"`
}

// QueryIncidentsRequest is the request for the QueryIncidents method.
type QueryIncidentsRequest struct {

	// Query describes the query to make.
	Query IncidentsQuery `json:"query"`

	// Cursor is used to page through results. Empty for the first page. For subsequent
	// pages, use previously returned Cursor values.
	Cursor Cursor `json:"cursor"`
}

// QueryIncidentsResponse is the response for the QueryIncidents method.
type QueryIncidentsResponse struct {

	// Incidents is a list of Incidents.
	Incidents []Incident `json:"incidents"`

	// Query is the query that was used to generate this response.
	Query IncidentsQuery `json:"query"`

	// Cursor should be passed back to get the next page of results.
	Cursor Cursor `json:"cursor"`
}

// QueryUsersRequest is the request for getting a list of users.
type QueryUsersRequest struct {

	// Query describes the query to make
	Query UsersQuery `json:"query"`

	// Cursor is used to page through results. Empty for the first page. For subsequent
	// pages, use previously returned Cursor values.
	Cursor Cursor `json:"cursor"`
}

// QueryUsersResponse is the response from QueryUsers.
type QueryUsersResponse struct {

	// Users is a list of Users.
	Users []User `json:"users"`

	// Query is the query that was used to generate this response.
	Query UsersQuery `json:"query"`

	// Cursor should be passed back to get the next page of results.
	Cursor Cursor `json:"cursor"`
}

// RemoveActivityRequest is the request for the RemoveActivity method.
type RemoveActivityRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// ActivityItemID is the unique identifier of the ActivityItem.
	ActivityItemID string `json:"activityItemID"`
}

// RemoveActivityResponse is the response from the RemoveActivity method.
type RemoveActivityResponse struct {

	// ActivityItem is the updated ActivityItem.
	ActivityItem ActivityItem `json:"activityItem"`
}

// RemoveLabelRequest is the request for the RemoveLabel method.
type RemoveLabelRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Label is the label to remove from the Incident.
	Label string `json:"label"`
}

// RemoveLabelResponse is the response for the RemoveLabel method.
type RemoveLabelResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// Role represents a role that will be used to assign people in the incident.
type Role struct {

	// RoleID is the unique ID of this role.
	RoleID int `json:"roleID"`

	// OrgID is the unique ID of the organization this role belongs to.
	OrgID string `json:"orgID"`

	// Name is the name of the role.
	Name string `json:"name"`

	// Description is the description of the role.
	Description string `json:"description"`

	// Important is whether this role is important.
	Important bool `json:"important"`

	// Mandatory is whether this role is mandatory.
	Mandatory bool `json:"mandatory"`

	// Archived is whether this role is archived. Archived roles are not allowed to be
	// assigned to people in the new incidents. But the historical data is still kept.
	Archived bool `json:"archived"`

	// CreatedAt is the time this role was created at.
	CreatedAt string `json:"createdAt"`

	// UpdatedAt is the time this role was updated at.
	UpdatedAt string `json:"updatedAt"`
}

// Task is an individual task that somebody will do to resolve an Incident.
type Task struct {

	// TaskID is the ID of the task.
	TaskID string `json:"taskID"`

	// Immutable is true if the task cannot be changed. Used for tasks created and
	// maintained by the system (like role assignment tasks).
	Immutable bool `json:"immutable"`

	// CreatedTime is the time the task was created.
	CreatedTime string `json:"createdTime"`

	// ModifiedTime is the time
	ModifiedTime string `json:"modifiedTime"`

	// Text is the string that describes the Task.
	Text string `json:"text"`

	// Status os the status of this task.
	Status string `json:"status"`

	// AuthorUser is the person who created this task.
	AuthorUser *UserPreview `json:"authorUser"`

	// AssignedUser is the person this task is assigned to.
	AssignedUser *UserPreview `json:"assignedUser"`
}

// TaskList is a list of tasks.
type TaskList struct {

	// Tasks is a list of tasks.
	Tasks []Task `json:"tasks"`

	// TodoCount is the number of items in the list that are not yet done.
	TodoCount int `json:"todoCount"`

	// DoneCount is the number of items in the list that are done.
	DoneCount int `json:"doneCount"`
}

// UnarchiveFieldRequest is the request struct for api UnarchiveField method.
type UnarchiveFieldRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`
}

// UnarchiveFieldResponse is the response from the UnarchiveField method.
type UnarchiveFieldResponse struct {
}

// UnarchiveRoleRequest is the request to unarchive a role.
type UnarchiveRoleRequest struct {

	// Role to be unarchived to the organization
	RoleID int `json:"roleID"`
}

// UnarchiveRoleResponse is the response to unarchive a role.
type UnarchiveRoleResponse struct {
}

// UnassignLabelByUUIDRequest is the request for the UnassignLabelByUUID method.
type UnassignLabelByUUIDRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// KeyUUID is the label key uuid.
	KeyUUID string `json:"keyUUID"`

	// ValueUUID is the UUID of the label value.
	ValueUUID string `json:"valueUUID"`
}

// UnassignLabelByUUIDResponse is the response from the UnassignLabelByUUID method.
type UnassignLabelByUUIDResponse struct {

	// Labels is a list of labels
	Labels []IncidentKeyValueLabel `json:"labels"`
}

// UnassignLabelRequest is the request for the UnassignLabel method.
type UnassignLabelRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Key is the label key.
	Key string `json:"key"`

	// Value is the value of the label.
	Value string `json:"value"`
}

// UnassignLabelResponse is the response from the UnassignLabel method.
type UnassignLabelResponse struct {

	// Labels is a list of labels
	Labels []IncidentKeyValueLabel `json:"labels"`
}

// UnassignRoleRequest is the request for the UnassignRole method.
type UnassignRoleRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// UserID is the identifier of the person to assign the role to.
	UserID string `json:"userID"`

	// Role is the role of this person.
	Role string `json:"role"`
}

// UnassignRoleResponse is the response for the UnassignRole method.
type UnassignRoleResponse struct {

	// Incident is the Incident that was just updated.
	Incident Incident `json:"incident"`

	// DidChange indicates if the role was changed or not. If the role was not
	// assigned, this will be false.
	DidChange bool `json:"didChange"`
}

// UpdateActivityBodyRequest is the request for the UpdateActivityBody method.
type UpdateActivityBodyRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// ActivityItemID is the unique identifier of the ActivityItem.
	ActivityItemID string `json:"activityItemID"`

	// Body is the new body to use for the given activity item
	Body string `json:"body"`
}

// UpdateActivityBodyResponse is the response from the UpdateActivityBody method.
type UpdateActivityBodyResponse struct {

	// ActivityItem is the updated ActivityItem.
	ActivityItem ActivityItem `json:"activityItem"`
}

// UpdateActivityEventTimeRequest is the request for the UpdateActivityEventTime
// method.
type UpdateActivityEventTimeRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// ActivityItemID is the unique identifier of the ActivityItem.
	ActivityItemID string `json:"activityItemID"`

	// EventTime is the time when the event occurred. If empty, the created time of the
	// activity item is used. The string value format should follow RFC 3339.
	EventTime string `json:"eventTime"`
}

// UpdateActivityEventTimeResponse is the response from the UpdateActivityEventTime
// method.
type UpdateActivityEventTimeResponse struct {

	// ActivityItem is the updated ActivityItem.
	ActivityItem ActivityItem `json:"activityItem"`
}

// UpdateActivityRelevanceRequest is the request for the UpdateActivityRelevance
// method.
type UpdateActivityRelevanceRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// ActivityItemID is the unique identifier of the ActivityItem.
	ActivityItemID string `json:"activityItemID"`

	// Relevance is the preferred relevance of the activity item. if set to 'automatic'
	// (the default), the relevance will be guessed automatically.
	Relevance string `json:"relevance"`
}

// UpdateActivityRelevanceResponse is the response from the UpdateActivityRelevance
// method.
type UpdateActivityRelevanceResponse struct {

	// ActivityItem is the updated ActivityItem.
	ActivityItem ActivityItem `json:"activityItem"`
}

// UpdateFieldRequest is the request struct for api UpdateField method.
type UpdateFieldRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`

	// Name is the name of the field.
	Name string `json:"name"`

	// Slug is the slug of the field. Used for searching and referencing the field as a
	// metric.
	Slug string `json:"slug"`

	// Color is the field color.
	Color string `json:"color"`

	// Icon is the field icon.
	Icon string `json:"icon"`

	// Description is the description of the field.
	Description string `json:"description"`

	// Required is whether this field is required.
	Required bool `json:"required"`

	// DomainName is single-select for which a field is valid/used.
	DomainName string `json:"domainName"`

	// Immutable indicates if the field can by modified by the user.
	Immutable bool `json:"immutable"`
}

// UpdateFieldResponse is the response from the UpdateField method.
type UpdateFieldResponse struct {

	// Field is the field that was updated.
	Field CustomMetadataField `json:"field"`
}

// UpdateFieldSelectOptionRequest is the request struct for UpdateFieldSelectOption
// method.
type UpdateFieldSelectOptionRequest struct {

	// FieldUUID is the UUID of the field.
	FieldUUID string `json:"fieldUUID"`

	// SelectOptionUUID is the UUID of the field select option to delete.
	SelectOptionUUID string `json:"selectOptionUUID"`

	// Value is the value of the select option.
	Value string `json:"value"`

	// Label is the label of the select option.
	Label string `json:"label"`

	// Color is the color of the select option.
	Color string `json:"color"`

	// Icon is the icon of the select option.
	Icon string `json:"icon"`

	// Description is the textual description of the option.
	Description string `json:"description"`
}

// UpdateFieldSelectOptionResponse is the response from the UpdateFieldSelectOption
// method.
type UpdateFieldSelectOptionResponse struct {
}

// UpdateIncidentEventTimeRequest is the request for the UpdateIncidentEventTime
// method.
type UpdateIncidentEventTimeRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// EventTime is the new time for the start or end of the incident. The string value
	// format should follow RFC 3339.
	EventTime string `json:"eventTime"`

	// ActivityItemKind is either the incidentEnd or incidentStart time. deprecated.
	// use EventName instead, ActivityItemKind will be removed soon.
	ActivityItemKind string `json:"activityItemKind"`

	// EventName is either the incidentEnd or incidentStart time.
	EventName string `json:"eventName"`
}

// UpdateIncidentEventTimeResponse is the response for the UpdateIncidentEventTime
// method.
type UpdateIncidentEventTimeResponse struct {
}

// UpdateIncidentIsDrillRequest is the request for the UpdateIncidentIsDrill
// method.
type UpdateIncidentIsDrillRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// IsDrill indicates whether the Incident is a drill or not.
	IsDrill bool `json:"isDrill"`
}

// UpdateIncidentIsDrillResponse is the response for the UpdateIncidentIsDrill
// method.
type UpdateIncidentIsDrillResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// UpdateRoleRequest is the request to update a role.
type UpdateRoleRequest struct {

	// Role to be updated to the organization
	Role Role `json:"role"`
}

// UpdateRoleResponse is the response to update a role.
type UpdateRoleResponse struct {

	// Role is the newly updated role.
	Role Role `json:"role"`
}

// UpdateSeverityRequest is the request for the UpdateSeverity method.
type UpdateSeverityRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Severity expresses how bad the Incident is.
	Severity string `json:"severity"`
}

// UpdateSeverityResponse is the response for the UpdateSeverity method.
type UpdateSeverityResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// UpdateStatusRequest is the request for the UpdateStatus method.
type UpdateStatusRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Status is the new status of the Incident.
	Status string `json:"status"`
}

// UpdateStatusResponse is the response for the UpdateStatus method.
type UpdateStatusResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// UpdateTaskStatusRequest is the request for the UpdateTaskStatus method.
type UpdateTaskStatusRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the Task to update.
	TaskID string `json:"taskID"`

	// Status is the new status of this task.
	Status string `json:"status"`
}

// UpdateTaskStatusResponse is the response from the UpdateTaskStatus method.
type UpdateTaskStatusResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// UpdateTaskTextRequest is the request for the UpdateTaskText method.
type UpdateTaskTextRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the task.
	TaskID string `json:"taskID"`

	// Text is the string that describes the Task.
	Text string `json:"text"`
}

// UpdateTaskTextResponse is the response from the UpdateTaskText method.
type UpdateTaskTextResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// UpdateTaskUserRequest is the request for the UpdateTaskUser method.
type UpdateTaskUserRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the Task to update.
	TaskID string `json:"taskID"`

	// UserID is the ID of the User to assign to the Task.
	UserID string `json:"userID"`
}

// UpdateTaskUserResponse is the response from the UpdateTaskUser method.
type UpdateTaskUserResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// UpdateTitleRequest is the request for the UpdateTitle method.
type UpdateTitleRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Title is the new title of the Incident.
	Title string `json:"title"`
}

// UpdateTitleResponse is the response for the UpdateTitle method.
type UpdateTitleResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// User contains the details of a person.
type User struct {

	// UserID is the identifier. It is in the format "provider:user-id" which
	// allows you to refer to users from different providers. Sometimes, the same
	// user is represented by multiple identifiers. You may always use this field
	// whenever you need to refer to a user, the server will resolve them for you.
	// "grafana-incident:{id}" is preferred.
	UserID string `json:"userID"`

	// InternalUserID is the internal user ID as stored in the database.
	InternalUserID string `json:"internalUserID"`

	// Email is the user's email address.
	Email string `json:"email"`

	// ModifiedTime is when this user was last modified. The string value format should
	// follow RFC 3339.
	ModifiedTime string `json:"modifiedTime"`

	// Name is the user full name.
	Name string `json:"name"`

	// PhotoURL is the user's photo URL.
	PhotoURL string `json:"photoURL"`

	// GrafanaUserID is the Grafana user ID.
	GrafanaUserID string `json:"grafanaUserID"`

	// GrafanaLogin is the Grafana login.
	GrafanaLogin string `json:"grafanaLogin"`

	// SlackUserID is the Slack user ID.
	SlackUserID string `json:"slackUserID"`

	// SlackTeamID is the Slack organization ID.
	SlackTeamID string `json:"slackTeamID"`

	// MsTeamsUserID is the MS Teams organization ID.
	MsTeamsUserID string `json:"msTeamsUserID"`
}

// UserPreview is a user involved in an Incident.
type UserPreview struct {

	// UserID is the identifier for the user.
	UserID string `json:"userID"`

	// Name is a human readable string that represents the user.
	Name string `json:"name"`

	// PhotoURL is the URL to the profile picture of the user.
	PhotoURL string `json:"photoURL"`
}

// UsersQuery is the request for getting a list of users.
type UsersQuery struct {

	// Limit is the max number of users to return.
	Limit int `json:"limit"`
}

// ActivityService provides access to incident activity. You can post notes to the
// timeline, and query and update the individual timeline items.
// Get one by calling NewActivityService.
type ActivityService struct {
	client *Client
}

// NewActivityService gets a new ActivityService.
func NewActivityService(client *Client) *ActivityService {
	return &ActivityService{
		client: client,
	}
}

// AddActivity posts an activity item to an Incident.
func (s *ActivityService) AddActivity(ctx context.Context, r AddActivityRequest) (*AddActivityResponse, error) {
	if s.client.stubmode {
		return s.stubAddActivity()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.AddActivity: marshal AddActivityRequest: %w", err)
	}
	url := s.client.RemoteHost + "ActivityService.AddActivity"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("ActivityService.AddActivity: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.AddActivity: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddActivityResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("ActivityService.AddActivity: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.AddActivity: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("ActivityService.AddActivity: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddActivityResponse, nil
}

// QueryActivity gets a selection of activity items.
func (s *ActivityService) QueryActivity(ctx context.Context, r QueryActivityRequest) (*QueryActivityResponse, error) {
	if s.client.stubmode {
		return s.stubQueryActivity()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.QueryActivity: marshal QueryActivityRequest: %w", err)
	}
	url := s.client.RemoteHost + "ActivityService.QueryActivity"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("ActivityService.QueryActivity: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.QueryActivity: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		QueryActivityResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("ActivityService.QueryActivity: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.QueryActivity: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("ActivityService.QueryActivity: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.QueryActivityResponse, nil
}

// RemoveActivity removes an activity item.
func (s *ActivityService) RemoveActivity(ctx context.Context, r RemoveActivityRequest) (*RemoveActivityResponse, error) {
	if s.client.stubmode {
		return s.stubRemoveActivity()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.RemoveActivity: marshal RemoveActivityRequest: %w", err)
	}
	url := s.client.RemoteHost + "ActivityService.RemoveActivity"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("ActivityService.RemoveActivity: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.RemoveActivity: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		RemoveActivityResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("ActivityService.RemoveActivity: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.RemoveActivity: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("ActivityService.RemoveActivity: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RemoveActivityResponse, nil
}

// UpdateActivityBody updates the body of a specific activity item.
func (s *ActivityService) UpdateActivityBody(ctx context.Context, r UpdateActivityBodyRequest) (*UpdateActivityBodyResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateActivityBody()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityBody: marshal UpdateActivityBodyRequest: %w", err)
	}
	url := s.client.RemoteHost + "ActivityService.UpdateActivityBody"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityBody: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityBody: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateActivityBodyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("ActivityService.UpdateActivityBody: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityBody: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("ActivityService.UpdateActivityBody: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateActivityBodyResponse, nil
}

// UpdateActivityEventTime updates the event time of a specific activity item.
func (s *ActivityService) UpdateActivityEventTime(ctx context.Context, r UpdateActivityEventTimeRequest) (*UpdateActivityEventTimeResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateActivityEventTime()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityEventTime: marshal UpdateActivityEventTimeRequest: %w", err)
	}
	url := s.client.RemoteHost + "ActivityService.UpdateActivityEventTime"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityEventTime: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityEventTime: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateActivityEventTimeResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("ActivityService.UpdateActivityEventTime: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityEventTime: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("ActivityService.UpdateActivityEventTime: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateActivityEventTimeResponse, nil
}

// UpdateActivityRelevance sets the relevance of an activity item.
func (s *ActivityService) UpdateActivityRelevance(ctx context.Context, r UpdateActivityRelevanceRequest) (*UpdateActivityRelevanceResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateActivityRelevance()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityRelevance: marshal UpdateActivityRelevanceRequest: %w", err)
	}
	url := s.client.RemoteHost + "ActivityService.UpdateActivityRelevance"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityRelevance: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityRelevance: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateActivityRelevanceResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("ActivityService.UpdateActivityRelevance: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("ActivityService.UpdateActivityRelevance: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("ActivityService.UpdateActivityRelevance: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateActivityRelevanceResponse, nil
}

// FieldsService provides access to the Fields API, responsible for managing custom
// metadata fields.
// Get one by calling NewFieldsService.
type FieldsService struct {
	client *Client
}

// NewFieldsService gets a new FieldsService.
func NewFieldsService(client *Client) *FieldsService {
	return &FieldsService{
		client: client,
	}
}

// AddField adds a new field to the org.
func (s *FieldsService) AddField(ctx context.Context, r AddFieldRequest) (*AddFieldResponse, error) {
	if s.client.stubmode {
		return s.stubAddField()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddField: marshal AddFieldRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.AddField"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddField: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddField: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddFieldResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.AddField: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddField: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.AddField: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddFieldResponse, nil
}

// AddFieldSelectOption adds a field select option.
func (s *FieldsService) AddFieldSelectOption(ctx context.Context, r AddFieldSelectOptionRequest) (*AddFieldSelectOptionResponse, error) {
	if s.client.stubmode {
		return s.stubAddFieldSelectOption()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddFieldSelectOption: marshal AddFieldSelectOptionRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.AddFieldSelectOption"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddFieldSelectOption: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddFieldSelectOption: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddFieldSelectOptionResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.AddFieldSelectOption: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddFieldSelectOption: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.AddFieldSelectOption: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddFieldSelectOptionResponse, nil
}

// AddLabelKey creates a field with the label domain.
func (s *FieldsService) AddLabelKey(ctx context.Context, r AddLabelKeyRequest) (*AddLabelKeyResponse, error) {
	if s.client.stubmode {
		return s.stubAddLabelKey()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelKey: marshal AddLabelKeyRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.AddLabelKey"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelKey: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelKey: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddLabelKeyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.AddLabelKey: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelKey: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.AddLabelKey: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddLabelKeyResponse, nil
}

// AddLabelValue adds a label value to a given label key.
func (s *FieldsService) AddLabelValue(ctx context.Context, r AddLabelValueRequest) (*AddLabelValueResponse, error) {
	if s.client.stubmode {
		return s.stubAddLabelValue()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelValue: marshal AddLabelValueRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.AddLabelValue"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelValue: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelValue: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddLabelValueResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.AddLabelValue: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.AddLabelValue: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.AddLabelValue: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddLabelValueResponse, nil
}

// ArchiveField archives a field.
func (s *FieldsService) ArchiveField(ctx context.Context, r ArchiveFieldRequest) (*ArchiveFieldResponse, error) {
	if s.client.stubmode {
		return s.stubArchiveField()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.ArchiveField: marshal ArchiveFieldRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.ArchiveField"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.ArchiveField: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.ArchiveField: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		ArchiveFieldResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.ArchiveField: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.ArchiveField: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.ArchiveField: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ArchiveFieldResponse, nil
}

// DeleteField deletes a field.
func (s *FieldsService) DeleteField(ctx context.Context, r DeleteFieldRequest) (*DeleteFieldResponse, error) {
	if s.client.stubmode {
		return s.stubDeleteField()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteField: marshal DeleteFieldRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.DeleteField"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteField: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteField: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		DeleteFieldResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.DeleteField: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteField: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.DeleteField: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DeleteFieldResponse, nil
}

// DeleteFieldSelectOption deletes a field select option.
func (s *FieldsService) DeleteFieldSelectOption(ctx context.Context, r DeleteFieldSelectOptionRequest) (*DeleteFieldSelectOptionResponse, error) {
	if s.client.stubmode {
		return s.stubDeleteFieldSelectOption()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteFieldSelectOption: marshal DeleteFieldSelectOptionRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.DeleteFieldSelectOption"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteFieldSelectOption: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteFieldSelectOption: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		DeleteFieldSelectOptionResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.DeleteFieldSelectOption: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.DeleteFieldSelectOption: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.DeleteFieldSelectOption: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DeleteFieldSelectOptionResponse, nil
}

// GetField returns fields in the org.
func (s *FieldsService) GetField(ctx context.Context, r GetFieldRequest) (*GetFieldResponse, error) {
	if s.client.stubmode {
		return s.stubGetField()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetField: marshal GetFieldRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.GetField"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetField: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetField: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetFieldResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.GetField: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetField: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.GetField: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetFieldResponse, nil
}

// GetFieldValues gets the key->value linked to a target.
func (s *FieldsService) GetFieldValues(ctx context.Context, r GetFieldValuesRequest) (*GetFieldValuesResponse, error) {
	if s.client.stubmode {
		return s.stubGetFieldValues()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFieldValues: marshal GetFieldValuesRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.GetFieldValues"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFieldValues: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFieldValues: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetFieldValuesResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.GetFieldValues: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFieldValues: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.GetFieldValues: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetFieldValuesResponse, nil
}

// GetFields returns a list of all custom fields in the org.
func (s *FieldsService) GetFields(ctx context.Context, r GetFieldsRequest) (*GetFieldsResponse, error) {
	if s.client.stubmode {
		return s.stubGetFields()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFields: marshal GetFieldsRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.GetFields"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFields: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFields: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetFieldsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.GetFields: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.GetFields: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.GetFields: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetFieldsResponse, nil
}

// UnarchiveField unarchives a field.
func (s *FieldsService) UnarchiveField(ctx context.Context, r UnarchiveFieldRequest) (*UnarchiveFieldResponse, error) {
	if s.client.stubmode {
		return s.stubUnarchiveField()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UnarchiveField: marshal UnarchiveFieldRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.UnarchiveField"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UnarchiveField: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UnarchiveField: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UnarchiveFieldResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.UnarchiveField: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UnarchiveField: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.UnarchiveField: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UnarchiveFieldResponse, nil
}

// UpdateField updates a field.
func (s *FieldsService) UpdateField(ctx context.Context, r UpdateFieldRequest) (*UpdateFieldResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateField()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateField: marshal UpdateFieldRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.UpdateField"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateField: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateField: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateFieldResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.UpdateField: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateField: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.UpdateField: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateFieldResponse, nil
}

// UpdateFieldSelectOption updates a field select option.
func (s *FieldsService) UpdateFieldSelectOption(ctx context.Context, r UpdateFieldSelectOptionRequest) (*UpdateFieldSelectOptionResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateFieldSelectOption()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateFieldSelectOption: marshal UpdateFieldSelectOptionRequest: %w", err)
	}
	url := s.client.RemoteHost + "FieldsService.UpdateFieldSelectOption"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateFieldSelectOption: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateFieldSelectOption: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateFieldSelectOptionResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("FieldsService.UpdateFieldSelectOption: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("FieldsService.UpdateFieldSelectOption: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("FieldsService.UpdateFieldSelectOption: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateFieldSelectOptionResponse, nil
}

// IncidentsService provides the ability to query, get, declare (create), update,
// and manage Incidents programatically. You can also assign roles and update
// labels.
// Get one by calling NewIncidentsService.
type IncidentsService struct {
	client *Client
}

// NewIncidentsService gets a new IncidentsService.
func NewIncidentsService(client *Client) *IncidentsService {
	return &IncidentsService{
		client: client,
	}
}

// AddLabel adds a label to the Incident.
func (s *IncidentsService) AddLabel(ctx context.Context, r AddLabelRequest) (*AddLabelResponse, error) {
	if s.client.stubmode {
		return s.stubAddLabel()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: marshal AddLabelRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.AddLabel"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddLabelResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.AddLabel: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.AddLabel: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddLabelResponse, nil
}

// AssignLabel assigns a key:value label to the incident
func (s *IncidentsService) AssignLabel(ctx context.Context, r AssignLabelRequest) (*AssignLabelResponse, error) {
	if s.client.stubmode {
		return s.stubAssignLabel()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabel: marshal AssignLabelRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.AssignLabel"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabel: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabel: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AssignLabelResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.AssignLabel: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabel: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.AssignLabel: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AssignLabelResponse, nil
}

// AssignLabelByUUID assigns a keyUUID:valueUUID label to the incident
func (s *IncidentsService) AssignLabelByUUID(ctx context.Context, r AssignLabelByUUIDRequest) (*AssignLabelByUUIDResponse, error) {
	if s.client.stubmode {
		return s.stubAssignLabelByUUID()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabelByUUID: marshal AssignLabelByUUIDRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.AssignLabelByUUID"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabelByUUID: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabelByUUID: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AssignLabelByUUIDResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.AssignLabelByUUID: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignLabelByUUID: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.AssignLabelByUUID: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AssignLabelByUUIDResponse, nil
}

// AssignRole assigns a role to a user.
func (s *IncidentsService) AssignRole(ctx context.Context, r AssignRoleRequest) (*AssignRoleResponse, error) {
	if s.client.stubmode {
		return s.stubAssignRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: marshal AssignRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.AssignRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AssignRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.AssignRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.AssignRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AssignRoleResponse, nil
}

// CreateIncident creates a new Incident.
func (s *IncidentsService) CreateIncident(ctx context.Context, r CreateIncidentRequest) (*CreateIncidentResponse, error) {
	if s.client.stubmode {
		return s.stubCreateIncident()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: marshal CreateIncidentRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.CreateIncident"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		CreateIncidentResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.CreateIncident: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.CreateIncident: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CreateIncidentResponse, nil
}

// GetIncident gets an existing Incident by ID.
func (s *IncidentsService) GetIncident(ctx context.Context, r GetIncidentRequest) (*GetIncidentResponse, error) {
	if s.client.stubmode {
		return s.stubGetIncident()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: marshal GetIncidentRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.GetIncident"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetIncidentResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.GetIncident: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.GetIncident: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetIncidentResponse, nil
}

// GetIncidentMembership will return the full list of people involved in an
// incident
func (s *IncidentsService) GetIncidentMembership(ctx context.Context, r GetIncidentMembershipRequest) (*GetIncidentMembershipResponse, error) {
	if s.client.stubmode {
		return s.stubGetIncidentMembership()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncidentMembership: marshal GetIncidentMembershipRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.GetIncidentMembership"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncidentMembership: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncidentMembership: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetIncidentMembershipResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.GetIncidentMembership: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncidentMembership: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.GetIncidentMembership: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetIncidentMembershipResponse, nil
}

// GetLabels get the labels from the incident.
func (s *IncidentsService) GetLabels(ctx context.Context, r GetLabelsRequest) (*GetLabelsResponse, error) {
	if s.client.stubmode {
		return s.stubGetLabels()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetLabels: marshal GetLabelsRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.GetLabels"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetLabels: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetLabels: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetLabelsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.GetLabels: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetLabels: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.GetLabels: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetLabelsResponse, nil
}

// QueryIncidentPreviews gets a list of Incident Previews.
func (s *IncidentsService) QueryIncidentPreviews(ctx context.Context, r QueryIncidentPreviewsRequest) (*QueryIncidentPreviewsResponse, error) {
	if s.client.stubmode {
		return s.stubQueryIncidentPreviews()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidentPreviews: marshal QueryIncidentPreviewsRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.QueryIncidentPreviews"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidentPreviews: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidentPreviews: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		QueryIncidentPreviewsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.QueryIncidentPreviews: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidentPreviews: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.QueryIncidentPreviews: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.QueryIncidentPreviewsResponse, nil
}

// QueryIncidents gets a list of Incidents.
// Deprecated: use QueryIncidentPreviews instead.
func (s *IncidentsService) QueryIncidents(ctx context.Context, r QueryIncidentsRequest) (*QueryIncidentsResponse, error) {
	if s.client.stubmode {
		return s.stubQueryIncidents()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: marshal QueryIncidentsRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.QueryIncidents"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		QueryIncidentsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.QueryIncidents: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.QueryIncidents: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.QueryIncidentsResponse, nil
}

// RemoveLabel removes a label from the Incident.
func (s *IncidentsService) RemoveLabel(ctx context.Context, r RemoveLabelRequest) (*RemoveLabelResponse, error) {
	if s.client.stubmode {
		return s.stubRemoveLabel()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: marshal RemoveLabelRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.RemoveLabel"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		RemoveLabelResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.RemoveLabel: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.RemoveLabel: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RemoveLabelResponse, nil
}

// UnassignLabel unassigns a key:value label from the incident
func (s *IncidentsService) UnassignLabel(ctx context.Context, r UnassignLabelRequest) (*UnassignLabelResponse, error) {
	if s.client.stubmode {
		return s.stubUnassignLabel()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabel: marshal UnassignLabelRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UnassignLabel"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabel: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabel: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UnassignLabelResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UnassignLabel: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabel: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UnassignLabel: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UnassignLabelResponse, nil
}

// UnassignLabelByUUID unassigns a keyUUID:valueUUID label from the incident
func (s *IncidentsService) UnassignLabelByUUID(ctx context.Context, r UnassignLabelByUUIDRequest) (*UnassignLabelByUUIDResponse, error) {
	if s.client.stubmode {
		return s.stubUnassignLabelByUUID()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabelByUUID: marshal UnassignLabelByUUIDRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UnassignLabelByUUID"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabelByUUID: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabelByUUID: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UnassignLabelByUUIDResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UnassignLabelByUUID: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignLabelByUUID: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UnassignLabelByUUID: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UnassignLabelByUUIDResponse, nil
}

// UnassignRole removes a role assignment from a user.
func (s *IncidentsService) UnassignRole(ctx context.Context, r UnassignRoleRequest) (*UnassignRoleResponse, error) {
	if s.client.stubmode {
		return s.stubUnassignRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: marshal UnassignRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UnassignRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UnassignRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UnassignRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UnassignRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UnassignRoleResponse, nil
}

// UpdateIncidentEventTime updates the start or end times of an Incident.
func (s *IncidentsService) UpdateIncidentEventTime(ctx context.Context, r UpdateIncidentEventTimeRequest) (*UpdateIncidentEventTimeResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateIncidentEventTime()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: marshal UpdateIncidentEventTimeRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateIncidentEventTime"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateIncidentEventTimeResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateIncidentEventTimeResponse, nil
}

// UpdateIncidentIsDrill changes whether an Incident is a drill or not.
func (s *IncidentsService) UpdateIncidentIsDrill(ctx context.Context, r UpdateIncidentIsDrillRequest) (*UpdateIncidentIsDrillResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateIncidentIsDrill()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: marshal UpdateIncidentIsDrillRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateIncidentIsDrill"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateIncidentIsDrillResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateIncidentIsDrillResponse, nil
}

// UpdateSeverity updates the severity of an Incident.
func (s *IncidentsService) UpdateSeverity(ctx context.Context, r UpdateSeverityRequest) (*UpdateSeverityResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateSeverity()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: marshal UpdateSeverityRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateSeverity"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateSeverityResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateSeverity: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateSeverity: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateSeverityResponse, nil
}

// UpdateStatus updates the status of an Incident.
func (s *IncidentsService) UpdateStatus(ctx context.Context, r UpdateStatusRequest) (*UpdateStatusResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateStatus()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: marshal UpdateStatusRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateStatus"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateStatusResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateStatus: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateStatus: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateStatusResponse, nil
}

// UpdateTitle updates the title of an Incident.
func (s *IncidentsService) UpdateTitle(ctx context.Context, r UpdateTitleRequest) (*UpdateTitleResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTitle()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: marshal UpdateTitleRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateTitle"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTitleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateTitle: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateTitle: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateTitleResponse, nil
}

// IntegrationService is used to install Integrations, and wire up hooks.
// Get one by calling NewIntegrationService.
type IntegrationService struct {
	client *Client
}

// NewIntegrationService gets a new IntegrationService.
func NewIntegrationService(client *Client) *IntegrationService {
	return &IntegrationService{
		client: client,
	}
}

// DisableHook disables a Hook.
func (s *IntegrationService) DisableHook(ctx context.Context, r DisableHookRequest) (*DisableHookResponse, error) {
	if s.client.stubmode {
		return s.stubDisableHook()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.DisableHook: marshal DisableHookRequest: %w", err)
	}
	url := s.client.RemoteHost + "IntegrationService.DisableHook"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.DisableHook: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.DisableHook: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		DisableHookResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IntegrationService.DisableHook: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.DisableHook: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IntegrationService.DisableHook: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DisableHookResponse, nil
}

// EnableHook wires up a Hook to an event.
func (s *IntegrationService) EnableHook(ctx context.Context, r EnableHookRequest) (*EnableHookResponse, error) {
	if s.client.stubmode {
		return s.stubEnableHook()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.EnableHook: marshal EnableHookRequest: %w", err)
	}
	url := s.client.RemoteHost + "IntegrationService.EnableHook"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.EnableHook: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.EnableHook: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		EnableHookResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IntegrationService.EnableHook: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.EnableHook: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IntegrationService.EnableHook: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EnableHookResponse, nil
}

// GetHookRuns gets a list of HookRuns for a given Incident.
func (s *IntegrationService) GetHookRuns(ctx context.Context, r GetHookRunsRequest) (*GetHookRunsResponse, error) {
	if s.client.stubmode {
		return s.stubGetHookRuns()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.GetHookRuns: marshal GetHookRunsRequest: %w", err)
	}
	url := s.client.RemoteHost + "IntegrationService.GetHookRuns"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.GetHookRuns: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.GetHookRuns: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetHookRunsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IntegrationService.GetHookRuns: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IntegrationService.GetHookRuns: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IntegrationService.GetHookRuns: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetHookRunsResponse, nil
}

// RolesService defines the interface for interacting with roles, providing CRUD
// operations and more fatures related to roles.
// Get one by calling NewRolesService.
type RolesService struct {
	client *Client
}

// NewRolesService gets a new RolesService.
func NewRolesService(client *Client) *RolesService {
	return &RolesService{
		client: client,
	}
}

// ArchiveRole archives a role.
func (s *RolesService) ArchiveRole(ctx context.Context, r ArchiveRoleRequest) (*ArchiveRoleResponse, error) {
	if s.client.stubmode {
		return s.stubArchiveRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("RolesService.ArchiveRole: marshal ArchiveRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "RolesService.ArchiveRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("RolesService.ArchiveRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("RolesService.ArchiveRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		ArchiveRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("RolesService.ArchiveRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("RolesService.ArchiveRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("RolesService.ArchiveRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ArchiveRoleResponse, nil
}

// CreateRole creates a role.
func (s *RolesService) CreateRole(ctx context.Context, r CreateRoleRequest) (*CreateRoleResponse, error) {
	if s.client.stubmode {
		return s.stubCreateRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("RolesService.CreateRole: marshal CreateRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "RolesService.CreateRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("RolesService.CreateRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("RolesService.CreateRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		CreateRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("RolesService.CreateRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("RolesService.CreateRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("RolesService.CreateRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CreateRoleResponse, nil
}

// DeleteRole deletes a role.
func (s *RolesService) DeleteRole(ctx context.Context, r DeleteRoleRequest) (*DeleteRoleResponse, error) {
	if s.client.stubmode {
		return s.stubDeleteRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("RolesService.DeleteRole: marshal DeleteRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "RolesService.DeleteRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("RolesService.DeleteRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("RolesService.DeleteRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		DeleteRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("RolesService.DeleteRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("RolesService.DeleteRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("RolesService.DeleteRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DeleteRoleResponse, nil
}

// GetRoles gets all roles.
func (s *RolesService) GetRoles(ctx context.Context, r GetRolesRequest) (*GetRolesResponse, error) {
	if s.client.stubmode {
		return s.stubGetRoles()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("RolesService.GetRoles: marshal GetRolesRequest: %w", err)
	}
	url := s.client.RemoteHost + "RolesService.GetRoles"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("RolesService.GetRoles: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("RolesService.GetRoles: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetRolesResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("RolesService.GetRoles: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("RolesService.GetRoles: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("RolesService.GetRoles: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetRolesResponse, nil
}

// UnarchiveRole unarchives a role.
func (s *RolesService) UnarchiveRole(ctx context.Context, r UnarchiveRoleRequest) (*UnarchiveRoleResponse, error) {
	if s.client.stubmode {
		return s.stubUnarchiveRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("RolesService.UnarchiveRole: marshal UnarchiveRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "RolesService.UnarchiveRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("RolesService.UnarchiveRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("RolesService.UnarchiveRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UnarchiveRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("RolesService.UnarchiveRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("RolesService.UnarchiveRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("RolesService.UnarchiveRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UnarchiveRoleResponse, nil
}

// UpdateRole updates a role.
func (s *RolesService) UpdateRole(ctx context.Context, r UpdateRoleRequest) (*UpdateRoleResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("RolesService.UpdateRole: marshal UpdateRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "RolesService.UpdateRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("RolesService.UpdateRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("RolesService.UpdateRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("RolesService.UpdateRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("RolesService.UpdateRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("RolesService.UpdateRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateRoleResponse, nil
}

// TasksService provides methods for managing tasks relating to Incidents.
// Get one by calling NewTasksService.
type TasksService struct {
	client *Client
}

// NewTasksService gets a new TasksService.
func NewTasksService(client *Client) *TasksService {
	return &TasksService{
		client: client,
	}
}

// AddTask adds a task to an Incident.
func (s *TasksService) AddTask(ctx context.Context, r AddTaskRequest) (*AddTaskResponse, error) {
	if s.client.stubmode {
		return s.stubAddTask()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: marshal AddTaskRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.AddTask"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddTaskResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.AddTask: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.AddTask: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddTaskResponse, nil
}

// DeleteTask deletes a task.
func (s *TasksService) DeleteTask(ctx context.Context, r DeleteTaskRequest) (*DeleteTaskResponse, error) {
	if s.client.stubmode {
		return s.stubDeleteTask()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: marshal DeleteTaskRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.DeleteTask"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		DeleteTaskResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.DeleteTask: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.DeleteTask: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DeleteTaskResponse, nil
}

// UpdateTaskStatus updates the task's Status.
func (s *TasksService) UpdateTaskStatus(ctx context.Context, r UpdateTaskStatusRequest) (*UpdateTaskStatusResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTaskStatus()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: marshal UpdateTaskStatusRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.UpdateTaskStatus"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTaskStatusResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.UpdateTaskStatus: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.UpdateTaskStatus: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateTaskStatusResponse, nil
}

// UpdateTaskText updates the task's text.
func (s *TasksService) UpdateTaskText(ctx context.Context, r UpdateTaskTextRequest) (*UpdateTaskTextResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTaskText()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: marshal UpdateTaskTextRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.UpdateTaskText"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTaskTextResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.UpdateTaskText: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.UpdateTaskText: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateTaskTextResponse, nil
}

// UpdateTaskUser updates the task's assigned user. Passing an empty user ID will
// clear the assigned user.
func (s *TasksService) UpdateTaskUser(ctx context.Context, r UpdateTaskUserRequest) (*UpdateTaskUserResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTaskUser()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: marshal UpdateTaskUserRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.UpdateTaskUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTaskUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.UpdateTaskUser: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.UpdateTaskUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateTaskUserResponse, nil
}

// UsersService provides services related to people in the system.
// Get one by calling NewUsersService.
type UsersService struct {
	client *Client
}

// NewUsersService gets a new UsersService.
func NewUsersService(client *Client) *UsersService {
	return &UsersService{
		client: client,
	}
}

// GetUser returns the information about a specific user.
func (s *UsersService) GetUser(ctx context.Context, r GetUserRequest) (*GetUserResponse, error) {
	if s.client.stubmode {
		return s.stubGetUser()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("UsersService.GetUser: marshal GetUserRequest: %w", err)
	}
	url := s.client.RemoteHost + "UsersService.GetUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("UsersService.GetUser: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("UsersService.GetUser: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("UsersService.GetUser: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("UsersService.GetUser: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("UsersService.GetUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetUserResponse, nil
}

// QueryUsers gets a list of users.
func (s *UsersService) QueryUsers(ctx context.Context, r QueryUsersRequest) (*QueryUsersResponse, error) {
	if s.client.stubmode {
		return s.stubQueryUsers()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("UsersService.QueryUsers: marshal QueryUsersRequest: %w", err)
	}
	url := s.client.RemoteHost + "UsersService.QueryUsers"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("UsersService.QueryUsers: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("User-Agent", UserAgent)
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("UsersService.QueryUsers: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		QueryUsersResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("UsersService.QueryUsers: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("UsersService.QueryUsers: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("UsersService.QueryUsers: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.QueryUsersResponse, nil
}

func (s *ActivityService) stubAddActivity() (*AddActivityResponse, error) {
	exampleJSON := `{
	"activityItem": {
		"activityItemID": "activity-item-123",
		"activityKind": "incidentCreated",
		"attachments": [
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			},
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			}
		],
		"body": "The incident was created by user-123",
		"createdTime": "2021-08-07T11:58:23Z",
		"eventTime": "2021-08-07T11:58:23Z",
		"fieldValues": {
			"something-else": true,
			"title": "new title"
		},
		"immutable": true,
		"incidentID": "incident-123",
		"relevance": "low",
		"subjectUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"tags": [
			"important"
		],
		"url": "https://meet.google.com/my-incident-room",
		"user": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		}
	},
	"error": "something went wrong"
}`
	var dest AddActivityResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddActivity: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *ActivityService) stubQueryActivity() (*QueryActivityResponse, error) {
	exampleJSON := `{
	"activityItems": [
		{
			"activityItemID": "activity-item-123",
			"activityKind": "incidentCreated",
			"attachments": [
				{
					"attachedByUserID": "user-123",
					"attachmentErr": "file too large",
					"attachmentID": "attachment-123",
					"contentLength": 123456,
					"contentType": "image/jpeg",
					"deletedTime": "2019-01-01T00:00:00Z",
					"displayType": "list",
					"downloadURL": "https://somewhere.com/path/to/filename.jpg",
					"ext": ".jpg",
					"fileType": "image",
					"hasThumbnail": true,
					"path": "filename.jpg",
					"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
					"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
					"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
					"uploadTime": "2019-01-01T00:00:00Z",
					"useSourceURL": true
				},
				{
					"attachedByUserID": "user-123",
					"attachmentErr": "file too large",
					"attachmentID": "attachment-123",
					"contentLength": 123456,
					"contentType": "image/jpeg",
					"deletedTime": "2019-01-01T00:00:00Z",
					"displayType": "list",
					"downloadURL": "https://somewhere.com/path/to/filename.jpg",
					"ext": ".jpg",
					"fileType": "image",
					"hasThumbnail": true,
					"path": "filename.jpg",
					"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
					"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
					"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
					"uploadTime": "2019-01-01T00:00:00Z",
					"useSourceURL": true
				}
			],
			"body": "The incident was created by user-123",
			"createdTime": "2021-08-07T11:58:23Z",
			"eventTime": "2021-08-07T11:58:23Z",
			"fieldValues": {
				"something-else": true,
				"title": "new title"
			},
			"immutable": true,
			"incidentID": "incident-123",
			"relevance": "low",
			"subjectUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"tags": [
				"important"
			],
			"url": "https://meet.google.com/my-incident-room",
			"user": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			}
		},
		{
			"activityItemID": "activity-item-123",
			"activityKind": "incidentCreated",
			"attachments": [
				{
					"attachedByUserID": "user-123",
					"attachmentErr": "file too large",
					"attachmentID": "attachment-123",
					"contentLength": 123456,
					"contentType": "image/jpeg",
					"deletedTime": "2019-01-01T00:00:00Z",
					"displayType": "list",
					"downloadURL": "https://somewhere.com/path/to/filename.jpg",
					"ext": ".jpg",
					"fileType": "image",
					"hasThumbnail": true,
					"path": "filename.jpg",
					"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
					"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
					"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
					"uploadTime": "2019-01-01T00:00:00Z",
					"useSourceURL": true
				},
				{
					"attachedByUserID": "user-123",
					"attachmentErr": "file too large",
					"attachmentID": "attachment-123",
					"contentLength": 123456,
					"contentType": "image/jpeg",
					"deletedTime": "2019-01-01T00:00:00Z",
					"displayType": "list",
					"downloadURL": "https://somewhere.com/path/to/filename.jpg",
					"ext": ".jpg",
					"fileType": "image",
					"hasThumbnail": true,
					"path": "filename.jpg",
					"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
					"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
					"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
					"uploadTime": "2019-01-01T00:00:00Z",
					"useSourceURL": true
				}
			],
			"body": "The incident was created by user-123",
			"createdTime": "2021-08-07T11:58:23Z",
			"eventTime": "2021-08-07T11:58:23Z",
			"fieldValues": {
				"something-else": true,
				"title": "new title"
			},
			"immutable": true,
			"incidentID": "incident-123",
			"relevance": "low",
			"subjectUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"tags": [
				"important"
			],
			"url": "https://meet.google.com/my-incident-room",
			"user": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			}
		}
	],
	"cursor": {
		"hasMore": true,
		"nextValue": "aaaabbbbccccddddeeeeffffgggg"
	},
	"error": "something went wrong",
	"query": {
		"activityKind": [
			"incidentCreated"
		],
		"incidentID": "incident-123",
		"limit": 10,
		"orderDirection": "ASC",
		"tag": "important"
	}
}`
	var dest QueryActivityResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubQueryActivity: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *ActivityService) stubRemoveActivity() (*RemoveActivityResponse, error) {
	exampleJSON := `{
	"activityItem": {
		"activityItemID": "activity-item-123",
		"activityKind": "incidentCreated",
		"attachments": [
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			},
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			}
		],
		"body": "The incident was created by user-123",
		"createdTime": "2021-08-07T11:58:23Z",
		"eventTime": "2021-08-07T11:58:23Z",
		"fieldValues": {
			"something-else": true,
			"title": "new title"
		},
		"immutable": true,
		"incidentID": "incident-123",
		"relevance": "low",
		"subjectUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"tags": [
			"important"
		],
		"url": "https://meet.google.com/my-incident-room",
		"user": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		}
	},
	"error": "something went wrong"
}`
	var dest RemoveActivityResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubRemoveActivity: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *ActivityService) stubUpdateActivityBody() (*UpdateActivityBodyResponse, error) {
	exampleJSON := `{
	"activityItem": {
		"activityItemID": "activity-item-123",
		"activityKind": "incidentCreated",
		"attachments": [
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			},
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			}
		],
		"body": "The incident was created by user-123",
		"createdTime": "2021-08-07T11:58:23Z",
		"eventTime": "2021-08-07T11:58:23Z",
		"fieldValues": {
			"something-else": true,
			"title": "new title"
		},
		"immutable": true,
		"incidentID": "incident-123",
		"relevance": "low",
		"subjectUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"tags": [
			"important"
		],
		"url": "https://meet.google.com/my-incident-room",
		"user": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		}
	},
	"error": "something went wrong"
}`
	var dest UpdateActivityBodyResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateActivityBody: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *ActivityService) stubUpdateActivityEventTime() (*UpdateActivityEventTimeResponse, error) {
	exampleJSON := `{
	"activityItem": {
		"activityItemID": "activity-item-123",
		"activityKind": "incidentCreated",
		"attachments": [
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			},
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			}
		],
		"body": "The incident was created by user-123",
		"createdTime": "2021-08-07T11:58:23Z",
		"eventTime": "2021-08-07T11:58:23Z",
		"fieldValues": {
			"something-else": true,
			"title": "new title"
		},
		"immutable": true,
		"incidentID": "incident-123",
		"relevance": "low",
		"subjectUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"tags": [
			"important"
		],
		"url": "https://meet.google.com/my-incident-room",
		"user": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		}
	},
	"error": "something went wrong"
}`
	var dest UpdateActivityEventTimeResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateActivityEventTime: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *ActivityService) stubUpdateActivityRelevance() (*UpdateActivityRelevanceResponse, error) {
	exampleJSON := `{
	"activityItem": {
		"activityItemID": "activity-item-123",
		"activityKind": "incidentCreated",
		"attachments": [
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			},
			{
				"attachedByUserID": "user-123",
				"attachmentErr": "file too large",
				"attachmentID": "attachment-123",
				"contentLength": 123456,
				"contentType": "image/jpeg",
				"deletedTime": "2019-01-01T00:00:00Z",
				"displayType": "list",
				"downloadURL": "https://somewhere.com/path/to/filename.jpg",
				"ext": ".jpg",
				"fileType": "image",
				"hasThumbnail": true,
				"path": "filename.jpg",
				"sHA512": "327232b67c88cba87c0a85a32bb192df527c21854d6515144d691f8cf1554f8e9969eed443b85e00d5ea21628c0ca4b6bbc9f26c837815fad6e9b3881cbb5cfd",
				"sourceURL": "https://somewhere-like-slack.com/path/to/filename.jpg",
				"thumbnailURL": "https://somewhere.com/path/to/thumbnail.jpg",
				"uploadTime": "2019-01-01T00:00:00Z",
				"useSourceURL": true
			}
		],
		"body": "The incident was created by user-123",
		"createdTime": "2021-08-07T11:58:23Z",
		"eventTime": "2021-08-07T11:58:23Z",
		"fieldValues": {
			"something-else": true,
			"title": "new title"
		},
		"immutable": true,
		"incidentID": "incident-123",
		"relevance": "low",
		"subjectUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"tags": [
			"important"
		],
		"url": "https://meet.google.com/my-incident-room",
		"user": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		}
	},
	"error": "something went wrong"
}`
	var dest UpdateActivityRelevanceResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateActivityRelevance: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubAddField() (*AddFieldResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"field": {
		"archived": "false",
		"color": "#FF00FF",
		"description": "field description",
		"domainName": "string",
		"externalID": "1",
		"icon": "fa-alt",
		"immutable": "false",
		"name": "field name",
		"required": "true",
		"selectoptions": [
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			},
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			}
		],
		"slug": "field_slug",
		"source": "incident",
		"type": "string",
		"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
	}
}`
	var dest AddFieldResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddField: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubAddFieldSelectOption() (*AddFieldSelectOptionResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"fieldSelectOptionUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f91333"
}`
	var dest AddFieldSelectOptionResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddFieldSelectOption: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubAddLabelKey() (*AddLabelKeyResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"field": {
		"archived": "false",
		"color": "#FF00FF",
		"description": "field description",
		"domainName": "string",
		"externalID": "1",
		"icon": "fa-alt",
		"immutable": "false",
		"name": "field name",
		"required": "true",
		"selectoptions": [
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			},
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			}
		],
		"slug": "field_slug",
		"source": "incident",
		"type": "string",
		"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
	}
}`
	var dest AddLabelKeyResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddLabelKey: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubAddLabelValue() (*AddLabelValueResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"field": {
		"archived": "false",
		"color": "#FF00FF",
		"description": "field description",
		"domainName": "string",
		"externalID": "1",
		"icon": "fa-alt",
		"immutable": "false",
		"name": "field name",
		"required": "true",
		"selectoptions": [
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			},
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			}
		],
		"slug": "field_slug",
		"source": "incident",
		"type": "string",
		"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
	}
}`
	var dest AddLabelValueResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddLabelValue: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubArchiveField() (*ArchiveFieldResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest ArchiveFieldResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubArchiveField: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubDeleteField() (*DeleteFieldResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest DeleteFieldResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubDeleteField: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubDeleteFieldSelectOption() (*DeleteFieldSelectOptionResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest DeleteFieldSelectOptionResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubDeleteFieldSelectOption: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubGetField() (*GetFieldResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"field": {
		"archived": "false",
		"color": "#FF00FF",
		"description": "field description",
		"domainName": "string",
		"externalID": "1",
		"icon": "fa-alt",
		"immutable": "false",
		"name": "field name",
		"required": "true",
		"selectoptions": [
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			},
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			}
		],
		"slug": "field_slug",
		"source": "incident",
		"type": "string",
		"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
	}
}`
	var dest GetFieldResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetField: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubGetFieldValues() (*GetFieldValuesResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"fieldValues": [
		{
			"field": {
				"archived": "false",
				"color": "#FF00FF",
				"description": "field description",
				"domainName": "string",
				"externalID": "1",
				"icon": "fa-alt",
				"immutable": "false",
				"name": "field name",
				"required": "true",
				"selectoptions": [
					{
						"color": "#000000",
						"description": "This label represents a new option",
						"externalID": "1",
						"icon": "file-alt",
						"label": "My field option name",
						"source": "incident",
						"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
						"value": "value"
					},
					{
						"color": "#000000",
						"description": "This label represents a new option",
						"externalID": "1",
						"icon": "file-alt",
						"label": "My field option name",
						"source": "incident",
						"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
						"value": "value"
					}
				],
				"slug": "field_slug",
				"source": "incident",
				"type": "string",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
			},
			"value": "value"
		},
		{
			"field": {
				"archived": "false",
				"color": "#FF00FF",
				"description": "field description",
				"domainName": "string",
				"externalID": "1",
				"icon": "fa-alt",
				"immutable": "false",
				"name": "field name",
				"required": "true",
				"selectoptions": [
					{
						"color": "#000000",
						"description": "This label represents a new option",
						"externalID": "1",
						"icon": "file-alt",
						"label": "My field option name",
						"source": "incident",
						"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
						"value": "value"
					},
					{
						"color": "#000000",
						"description": "This label represents a new option",
						"externalID": "1",
						"icon": "file-alt",
						"label": "My field option name",
						"source": "incident",
						"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
						"value": "value"
					}
				],
				"slug": "field_slug",
				"source": "incident",
				"type": "string",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
			},
			"value": "value"
		}
	]
}`
	var dest GetFieldValuesResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetFieldValues: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubGetFields() (*GetFieldsResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"fields": [
		{
			"archived": "false",
			"color": "#FF00FF",
			"description": "field description",
			"domainName": "string",
			"externalID": "1",
			"icon": "fa-alt",
			"immutable": "false",
			"name": "field name",
			"required": "true",
			"selectoptions": [
				{
					"color": "#000000",
					"description": "This label represents a new option",
					"externalID": "1",
					"icon": "file-alt",
					"label": "My field option name",
					"source": "incident",
					"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				},
				{
					"color": "#000000",
					"description": "This label represents a new option",
					"externalID": "1",
					"icon": "file-alt",
					"label": "My field option name",
					"source": "incident",
					"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				}
			],
			"slug": "field_slug",
			"source": "incident",
			"type": "string",
			"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
		},
		{
			"archived": "false",
			"color": "#FF00FF",
			"description": "field description",
			"domainName": "string",
			"externalID": "1",
			"icon": "fa-alt",
			"immutable": "false",
			"name": "field name",
			"required": "true",
			"selectoptions": [
				{
					"color": "#000000",
					"description": "This label represents a new option",
					"externalID": "1",
					"icon": "file-alt",
					"label": "My field option name",
					"source": "incident",
					"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				},
				{
					"color": "#000000",
					"description": "This label represents a new option",
					"externalID": "1",
					"icon": "file-alt",
					"label": "My field option name",
					"source": "incident",
					"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				}
			],
			"slug": "field_slug",
			"source": "incident",
			"type": "string",
			"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
		}
	]
}`
	var dest GetFieldsResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetFields: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubUnarchiveField() (*UnarchiveFieldResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest UnarchiveFieldResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUnarchiveField: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubUpdateField() (*UpdateFieldResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"field": {
		"archived": "false",
		"color": "#FF00FF",
		"description": "field description",
		"domainName": "string",
		"externalID": "1",
		"icon": "fa-alt",
		"immutable": "false",
		"name": "field name",
		"required": "true",
		"selectoptions": [
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			},
			{
				"color": "#000000",
				"description": "This label represents a new option",
				"externalID": "1",
				"icon": "file-alt",
				"label": "My field option name",
				"source": "incident",
				"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
				"value": "value"
			}
		],
		"slug": "field_slug",
		"source": "incident",
		"type": "string",
		"uuid": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f"
	}
}`
	var dest UpdateFieldResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateField: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *FieldsService) stubUpdateFieldSelectOption() (*UpdateFieldSelectOptionResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest UpdateFieldSelectOptionResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateFieldSelectOption: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubAddLabel() (*AddLabelResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest AddLabelResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddLabel: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubAssignLabel() (*AssignLabelResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"labels": [
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		},
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		}
	]
}`
	var dest AssignLabelResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAssignLabel: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubAssignLabelByUUID() (*AssignLabelByUUIDResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"labels": [
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		},
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		}
	]
}`
	var dest AssignLabelByUUIDResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAssignLabelByUUID: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubAssignRole() (*AssignRoleResponse, error) {
	exampleJSON := `{
	"didChange": true,
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest AssignRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAssignRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubCreateIncident() (*CreateIncidentResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest CreateIncidentResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubCreateIncident: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubGetIncident() (*GetIncidentResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest GetIncidentResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetIncident: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubGetIncidentMembership() (*GetIncidentMembershipResponse, error) {
	exampleJSON := `{
	"assignments": [
		{
			"role": {
				"archived": true,
				"createdAt": "2020-01-01T00:00:00Z",
				"description": "The commander is the incident commander.",
				"important": true,
				"mandatory": true,
				"name": "commander",
				"orgID": "org-1",
				"roleID": 1,
				"updatedAt": "2020-01-01T00:00:00Z"
			},
			"roleID": 1,
			"user": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			}
		},
		{
			"role": {
				"archived": true,
				"createdAt": "2020-01-01T00:00:00Z",
				"description": "The commander is the incident commander.",
				"important": true,
				"mandatory": true,
				"name": "commander",
				"orgID": "org-1",
				"roleID": 1,
				"updatedAt": "2020-01-01T00:00:00Z"
			},
			"roleID": 1,
			"user": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			}
		}
	],
	"error": "something went wrong"
}`
	var dest GetIncidentMembershipResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetIncidentMembership: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubGetLabels() (*GetLabelsResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"labels": [
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		},
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		}
	]
}`
	var dest GetLabelsResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetLabels: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubQueryIncidentPreviews() (*QueryIncidentPreviewsResponse, error) {
	exampleJSON := `{
	"cursor": {
		"hasMore": true,
		"nextValue": "aaaabbbbccccddddeeeeffffgggg"
	},
	"error": "something went wrong",
	"incidentPreviews": [
		{
			"closedTime": "2021-08-07T11:58:23Z",
			"createdByUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"createdTime": "2021-08-07T11:58:23Z",
			"description": "Looks like there is a problem with the load balancers...",
			"fieldValues": [
				{
					"fieldUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				},
				{
					"fieldUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				}
			],
			"heroImagePath": "/incident/api/hero-images/1234/mb6SVYPti2uY1qOokhs2mavgMFOtqDe/v1234/1234.png",
			"incidentEnd": "2022-02-11 00:50:20.574137",
			"incidentID": "incident-123",
			"incidentMembershipPreview": {
				"importantAssignments": [
					{
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					},
					{
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					}
				],
				"totalAssignments": 5,
				"totalParticipants": 3
			},
			"incidentStart": "2022-02-11 00:50:20.574137",
			"incidentType": "internal",
			"isDrill": true,
			"labels": [
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				},
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				}
			],
			"modifiedTime": "2021-08-07T11:58:23Z",
			"severityID": "severity-123",
			"severityLabel": "major",
			"slug": "high-latency-in-web-requests",
			"status": "active",
			"summary": "Lighting struck the server so we lost some throughput. We sprayed it with an 8-bit fire extinguisher and now it's back to normal.",
			"title": "high latency in web requests",
			"version": 4
		},
		{
			"closedTime": "2021-08-07T11:58:23Z",
			"createdByUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"createdTime": "2021-08-07T11:58:23Z",
			"description": "Looks like there is a problem with the load balancers...",
			"fieldValues": [
				{
					"fieldUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				},
				{
					"fieldUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
					"value": "value"
				}
			],
			"heroImagePath": "/incident/api/hero-images/1234/mb6SVYPti2uY1qOokhs2mavgMFOtqDe/v1234/1234.png",
			"incidentEnd": "2022-02-11 00:50:20.574137",
			"incidentID": "incident-123",
			"incidentMembershipPreview": {
				"importantAssignments": [
					{
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					},
					{
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					}
				],
				"totalAssignments": 5,
				"totalParticipants": 3
			},
			"incidentStart": "2022-02-11 00:50:20.574137",
			"incidentType": "internal",
			"isDrill": true,
			"labels": [
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				},
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				}
			],
			"modifiedTime": "2021-08-07T11:58:23Z",
			"severityID": "severity-123",
			"severityLabel": "major",
			"slug": "high-latency-in-web-requests",
			"status": "active",
			"summary": "Lighting struck the server so we lost some throughput. We sprayed it with an 8-bit fire extinguisher and now it's back to normal.",
			"title": "high latency in web requests",
			"version": 4
		}
	],
	"query": {
		"limit": 10,
		"orderDirection": "ASC",
		"orderField": "createdTime",
		"queryString": "isdrill:false or(label:security label:important)"
	}
}`
	var dest QueryIncidentPreviewsResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubQueryIncidentPreviews: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubQueryIncidents() (*QueryIncidentsResponse, error) {
	exampleJSON := `{
	"cursor": {
		"hasMore": true,
		"nextValue": "aaaabbbbccccddddeeeeffffgggg"
	},
	"error": "something went wrong",
	"incidents": [
		{
			"closedTime": "2021-08-07T11:58:23Z",
			"createdByUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"createdTime": "2021-08-07T11:58:23Z",
			"durationSeconds": 60,
			"heroImagePath": "/relative/path/to/hero/image.png",
			"incidentEnd": "2022-02-11 00:50:20.574137",
			"incidentID": "incident-123",
			"incidentMembership": {
				"assignments": [
					{
						"role": {
							"archived": true,
							"createdAt": "2020-01-01T00:00:00Z",
							"description": "The commander is the incident commander.",
							"important": true,
							"mandatory": true,
							"name": "commander",
							"orgID": "org-1",
							"roleID": 1,
							"updatedAt": "2020-01-01T00:00:00Z"
						},
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					},
					{
						"role": {
							"archived": true,
							"createdAt": "2020-01-01T00:00:00Z",
							"description": "The commander is the incident commander.",
							"important": true,
							"mandatory": true,
							"name": "commander",
							"orgID": "org-1",
							"roleID": 1,
							"updatedAt": "2020-01-01T00:00:00Z"
						},
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					}
				],
				"totalAssignments": 5,
				"totalParticipants": 3
			},
			"incidentStart": "2022-02-11 00:50:20.574137",
			"isDrill": true,
			"labels": [
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				},
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				}
			],
			"modifiedTime": "2021-08-07T11:58:23Z",
			"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
			"severity": "minor",
			"status": "active",
			"summary": "Something happened, we found out something interesting, then we fixed it.",
			"taskList": {
				"doneCount": 8,
				"tasks": [
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					},
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					}
				],
				"todoCount": 5
			},
			"title": "high latency in web requests"
		},
		{
			"closedTime": "2021-08-07T11:58:23Z",
			"createdByUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"createdTime": "2021-08-07T11:58:23Z",
			"durationSeconds": 60,
			"heroImagePath": "/relative/path/to/hero/image.png",
			"incidentEnd": "2022-02-11 00:50:20.574137",
			"incidentID": "incident-123",
			"incidentMembership": {
				"assignments": [
					{
						"role": {
							"archived": true,
							"createdAt": "2020-01-01T00:00:00Z",
							"description": "The commander is the incident commander.",
							"important": true,
							"mandatory": true,
							"name": "commander",
							"orgID": "org-1",
							"roleID": 1,
							"updatedAt": "2020-01-01T00:00:00Z"
						},
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					},
					{
						"role": {
							"archived": true,
							"createdAt": "2020-01-01T00:00:00Z",
							"description": "The commander is the incident commander.",
							"important": true,
							"mandatory": true,
							"name": "commander",
							"orgID": "org-1",
							"roleID": 1,
							"updatedAt": "2020-01-01T00:00:00Z"
						},
						"roleID": 1,
						"user": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						}
					}
				],
				"totalAssignments": 5,
				"totalParticipants": 3
			},
			"incidentStart": "2022-02-11 00:50:20.574137",
			"isDrill": true,
			"labels": [
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				},
				{
					"colorHex": "#ff0000",
					"description": "Customers are affected by this incident.",
					"key": "service_name",
					"label": "customers-affected"
				}
			],
			"modifiedTime": "2021-08-07T11:58:23Z",
			"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
			"severity": "minor",
			"status": "active",
			"summary": "Something happened, we found out something interesting, then we fixed it.",
			"taskList": {
				"doneCount": 8,
				"tasks": [
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					},
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					}
				],
				"todoCount": 5
			},
			"title": "high latency in web requests"
		}
	],
	"query": {
		"dateFrom": "2021-01-01T02:07:14+00:00",
		"dateTo": "2021-01-01T02:07:14+00:00",
		"excludeStatuses": [
			"closed"
		],
		"incidentLabels": [
			"security",
			"customersaffected"
		],
		"includeStatuses": [
			"active"
		],
		"limit": 10,
		"onlyDrills": true,
		"orderDirection": "ASC",
		"queryString": "isdrill:false any(label:security label:important)",
		"severity": "major"
	}
}`
	var dest QueryIncidentsResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubQueryIncidents: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubRemoveLabel() (*RemoveLabelResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest RemoveLabelResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubRemoveLabel: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUnassignLabel() (*UnassignLabelResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"labels": [
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		},
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		}
	]
}`
	var dest UnassignLabelResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUnassignLabel: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUnassignLabelByUUID() (*UnassignLabelByUUIDResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"labels": [
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		},
		{
			"colorHex": "#ff0000",
			"description": "Customers are affected by this incident.",
			"key": "service_name",
			"keyUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9180f",
			"value": "customers-affected",
			"valueUUID": "3fb1e5d7-3ef2-11ef-b731-deab26f9160f"
		}
	]
}`
	var dest UnassignLabelByUUIDResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUnassignLabelByUUID: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUnassignRole() (*UnassignRoleResponse, error) {
	exampleJSON := `{
	"didChange": true,
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UnassignRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUnassignRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateIncidentEventTime() (*UpdateIncidentEventTimeResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest UpdateIncidentEventTimeResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateIncidentEventTime: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateIncidentIsDrill() (*UpdateIncidentIsDrillResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateIncidentIsDrillResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateIncidentIsDrill: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateSeverity() (*UpdateSeverityResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateSeverityResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateSeverity: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateStatus() (*UpdateStatusResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateStatusResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateStatus: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateTitle() (*UpdateTitleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": 60,
		"heroImagePath": "/relative/path/to/hero/image.png",
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentMembership": {
			"assignments": [
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"role": {
						"archived": true,
						"createdAt": "2020-01-01T00:00:00Z",
						"description": "The commander is the incident commander.",
						"important": true,
						"mandatory": true,
						"name": "commander",
						"orgID": "org-1",
						"roleID": 1,
						"updatedAt": "2020-01-01T00:00:00Z"
					},
					"roleID": 1,
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"totalAssignments": 5,
			"totalParticipants": 3
		},
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": true,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			},
			{
				"colorHex": "#ff0000",
				"description": "Customers are affected by this incident.",
				"key": "service_name",
				"label": "customers-affected"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"severity": "minor",
		"status": "active",
		"summary": "Something happened, we found out something interesting, then we fixed it.",
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateTitleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTitle: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IntegrationService) stubDisableHook() (*DisableHookResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest DisableHookResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubDisableHook: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IntegrationService) stubEnableHook() (*EnableHookResponse, error) {
	exampleJSON := `{
	"enabledHookID": "enabled-hook-123",
	"error": "something went wrong"
}`
	var dest EnableHookResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubEnableHook: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IntegrationService) stubGetHookRuns() (*GetHookRunsResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"hookRuns": [
		{
			"enabledHookID": "enabled-hook-123",
			"error": "Something went wrong",
			"eventKind": "updatedRole",
			"eventName": "incidentCreated",
			"hookID": "hook-123",
			"integrationID": "integration-123",
			"lastRun": "2020-01-01T00:00:00Z",
			"lastUpdate": "2020-01-01T00:00:00Z",
			"metadata": {
				"explanation": "A meeting was created.",
				"title": "Meeting Created",
				"url": "https://somewhere.com/123"
			},
			"status": "todo",
			"updateError": "failed to connect",
			"updateStatus": "todo"
		},
		{
			"enabledHookID": "enabled-hook-123",
			"error": "Something went wrong",
			"eventKind": "updatedRole",
			"eventName": "incidentCreated",
			"hookID": "hook-123",
			"integrationID": "integration-123",
			"lastRun": "2020-01-01T00:00:00Z",
			"lastUpdate": "2020-01-01T00:00:00Z",
			"metadata": {
				"explanation": "A meeting was created.",
				"title": "Meeting Created",
				"url": "https://somewhere.com/123"
			},
			"status": "todo",
			"updateError": "failed to connect",
			"updateStatus": "todo"
		}
	]
}`
	var dest GetHookRunsResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetHookRuns: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *RolesService) stubArchiveRole() (*ArchiveRoleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest ArchiveRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubArchiveRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *RolesService) stubCreateRole() (*CreateRoleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"role": {
		"archived": true,
		"createdAt": "2020-01-01T00:00:00Z",
		"description": "The commander is the incident commander.",
		"important": true,
		"mandatory": true,
		"name": "commander",
		"orgID": "org-1",
		"roleID": 1,
		"updatedAt": "2020-01-01T00:00:00Z"
	}
}`
	var dest CreateRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubCreateRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *RolesService) stubDeleteRole() (*DeleteRoleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest DeleteRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubDeleteRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *RolesService) stubGetRoles() (*GetRolesResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"roles": [
		{
			"archived": true,
			"createdAt": "2020-01-01T00:00:00Z",
			"description": "The commander is the incident commander.",
			"important": true,
			"mandatory": true,
			"name": "commander",
			"orgID": "org-1",
			"roleID": 1,
			"updatedAt": "2020-01-01T00:00:00Z"
		},
		{
			"archived": true,
			"createdAt": "2020-01-01T00:00:00Z",
			"description": "The commander is the incident commander.",
			"important": true,
			"mandatory": true,
			"name": "commander",
			"orgID": "org-1",
			"roleID": 1,
			"updatedAt": "2020-01-01T00:00:00Z"
		}
	]
}`
	var dest GetRolesResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetRoles: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *RolesService) stubUnarchiveRole() (*UnarchiveRoleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest UnarchiveRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUnarchiveRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *RolesService) stubUpdateRole() (*UpdateRoleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"role": {
		"archived": true,
		"createdAt": "2020-01-01T00:00:00Z",
		"description": "The commander is the incident commander.",
		"important": true,
		"mandatory": true,
		"name": "commander",
		"orgID": "org-1",
		"roleID": 1,
		"updatedAt": "2020-01-01T00:00:00Z"
	}
}`
	var dest UpdateRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubAddTask() (*AddTaskResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest AddTaskResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddTask: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubDeleteTask() (*DeleteTaskResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest DeleteTaskResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubDeleteTask: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubUpdateTaskStatus() (*UpdateTaskStatusResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest UpdateTaskStatusResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTaskStatus: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubUpdateTaskText() (*UpdateTaskTextResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest UpdateTaskTextResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTaskText: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubUpdateTaskUser() (*UpdateTaskUserResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest UpdateTaskUserResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTaskUser: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *UsersService) stubGetUser() (*GetUserResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"user": {
		"email": "you@company.com",
		"grafanaLogin": "admin",
		"grafanaUserID": "123",
		"internalUserID": "user-12345",
		"modifiedTime": "2021-08-07T11:58:23Z",
		"msTeamsUserID": "26e2b619-b955-483f-a519-c8950aacbaa9",
		"name": "Morty Smith",
		"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
		"slackTeamID": "DEF123456",
		"slackUserID": "ABC123456",
		"userID": "grafana-incident:123"
	}
}`
	var dest GetUserResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetUser: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *UsersService) stubQueryUsers() (*QueryUsersResponse, error) {
	exampleJSON := `{
	"cursor": {
		"hasMore": true,
		"nextValue": "aaaabbbbccccddddeeeeffffgggg"
	},
	"error": "something went wrong",
	"query": {
		"limit": 10
	},
	"users": [
		{
			"email": "you@company.com",
			"grafanaLogin": "admin",
			"grafanaUserID": "123",
			"internalUserID": "user-12345",
			"modifiedTime": "2021-08-07T11:58:23Z",
			"msTeamsUserID": "26e2b619-b955-483f-a519-c8950aacbaa9",
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"slackTeamID": "DEF123456",
			"slackUserID": "ABC123456",
			"userID": "grafana-incident:123"
		},
		{
			"email": "you@company.com",
			"grafanaLogin": "admin",
			"grafanaUserID": "123",
			"internalUserID": "user-12345",
			"modifiedTime": "2021-08-07T11:58:23Z",
			"msTeamsUserID": "26e2b619-b955-483f-a519-c8950aacbaa9",
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"slackTeamID": "DEF123456",
			"slackUserID": "ABC123456",
			"userID": "grafana-incident:123"
		}
	]
}`
	var dest QueryUsersResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubQueryUsers: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

// Options contains constants to use for various fields across the API.
// It follows Options.{ObjectName}{FieldName}.{Option} structure, for example
// Options.IncidentSeverity.Pending.
var Options struct {

	// ActivityItemActivityKind contains the acceptable values for the
	// ActivityItem.ActivityKind field.
	ActivityItemActivityKind struct {

		// IncidentUpdated == "incidentUpdated"
		IncidentUpdated string

		// IncidentTitleChanged == "incidentTitleChanged"
		IncidentTitleChanged string

		// IncidentStatusChanged == "incidentStatusChanged"
		IncidentStatusChanged string

		// IncidentSeverityChanged == "incidentSeverityChanged"
		IncidentSeverityChanged string

		// IncidentCreated == "incidentCreated"
		IncidentCreated string

		// IncidentDeleted == "incidentDeleted"
		IncidentDeleted string

		// IncidentClosed == "incidentClosed"
		IncidentClosed string

		// RoleAssigned == "roleAssigned"
		RoleAssigned string

		// RoleUnassigned == "roleUnassigned"
		RoleUnassigned string

		// ActionRun == "actionRun"
		ActionRun string

		// UserNote == "userNote"
		UserNote string

		// DataQuery == "dataQuery"
		DataQuery string

		// HookRunMetadata == "hookRunMetadata"
		HookRunMetadata string

		// TaskAdded == "taskAdded"
		TaskAdded string

		// TaskUpdated == "taskUpdated"
		TaskUpdated string

		// TaskCompleted == "taskCompleted"
		TaskCompleted string

		// TaskDeleted == "taskDeleted"
		TaskDeleted string

		// MessageReaction == "messageReaction"
		MessageReaction string

		// ContextAttached == "contextAttached"
		ContextAttached string

		// IncidentIsDrillChanged == "incidentIsDrillChanged"
		IncidentIsDrillChanged string

		// IncidentStart == "incidentStart"
		IncidentStart string

		// IncidentEnd == "incidentEnd"
		IncidentEnd string

		// IncidentSummary == "incidentSummary"
		IncidentSummary string

		// LabelAdded == "labelAdded"
		LabelAdded string

		// LabelRemoved == "labelRemoved"
		LabelRemoved string

		// SiftResult == "siftResult"
		SiftResult string
	}

	// ActivityItemRelevance contains the acceptable values for the
	// ActivityItem.Relevance field.
	ActivityItemRelevance struct {

		// Automatic == "automatic"
		Automatic string

		// Archive == "archive"
		Archive string

		// Low == "low"
		Low string

		// Normal == "normal"
		Normal string

		// High == "high"
		High string
	}

	// ActivityQueryOrderDirection contains the acceptable values for the
	// ActivityQuery.OrderDirection field.
	ActivityQueryOrderDirection struct {

		// ASC == "ASC"
		ASC string

		// DESC == "DESC"
		DESC string
	}

	// AddActivityRequestActivityKind contains the acceptable values for the
	// AddActivityRequest.ActivityKind field.
	AddActivityRequestActivityKind struct {

		// UserNote == "userNote"
		UserNote string
	}

	// AssignRoleRequestRole contains the acceptable values for the
	// AssignRoleRequest.Role field.
	AssignRoleRequestRole struct {

		// Commander == "commander"
		Commander string

		// Investigator == "investigator"
		Investigator string

		// Observer == "observer"
		Observer string
	}

	// AttachmentFileType contains the acceptable values for the
	// Attachment.FileType field.
	AttachmentFileType struct {

		// File == "file"
		File string

		// Video == "video"
		Video string

		// Image == "image"
		Image string

		// Audio == "audio"
		Audio string

		// Screenshare == "screenshare"
		Screenshare string
	}

	// AttachmentDisplayType contains the acceptable values for the
	// Attachment.DisplayType field.
	AttachmentDisplayType struct {

		// List == "list"
		List string

		// Embed == "embed"
		Embed string
	}

	// CreateIncidentRequestStatus contains the acceptable values for the
	// CreateIncidentRequest.Status field.
	CreateIncidentRequestStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// CustomMetadataFieldType contains the acceptable values for the
	// CustomMetadataField.Type field.
	CustomMetadataFieldType struct {

		// String == "string"
		String string

		// SingleSelect == "single-select"
		SingleSelect string

		// MultiSelect == "multi-select"
		MultiSelect string

		// Bool == "bool"
		Bool string

		// Number == "number"
		Number string

		// Date == "date"
		Date string
	}

	// CustomMetadataFieldDomainName contains the acceptable values for the
	// CustomMetadataField.DomainName field.
	CustomMetadataFieldDomainName struct {

		// Labels == "labels"
		Labels string

		// Incident == "incident"
		Incident string
	}

	// EnableHookRequestEventName contains the acceptable values for the
	// EnableHookRequest.EventName field.
	EnableHookRequestEventName struct {

		// IncidentCreated == "incidentCreated"
		IncidentCreated string

		// IncidentDeleted == "incidentDeleted"
		IncidentDeleted string

		// IncidentUpdated == "incidentUpdated"
		IncidentUpdated string

		// IncidentClosed == "incidentClosed"
		IncidentClosed string

		// ManuallyTriggered == "manuallyTriggered"
		ManuallyTriggered string

		// IncidentFilter == "incidentFilter"
		IncidentFilter string
	}

	// FieldType contains the acceptable values for the
	// Field.Type field.
	FieldType struct {

		// String == "string"
		String string

		// StringGrafanaAPIKeyViewer == "string[grafana.apiKey:viewer]"
		StringGrafanaAPIKeyViewer string

		// StringGrafanaAPIKeyAdmin == "string[grafana.apiKey:admin]"
		StringGrafanaAPIKeyAdmin string

		// Bool == "bool"
		Bool string
	}

	// GetFieldValuesRequestTargetKind contains the acceptable values for the
	// GetFieldValuesRequest.TargetKind field.
	GetFieldValuesRequestTargetKind struct {

		// Incident == "incident"
		Incident string
	}

	// HookRunEventName contains the acceptable values for the
	// HookRun.EventName field.
	HookRunEventName struct {

		// IncidentCreated == "incidentCreated"
		IncidentCreated string

		// IncidentDeleted == "incidentDeleted"
		IncidentDeleted string

		// IncidentUpdated == "incidentUpdated"
		IncidentUpdated string

		// IncidentClosed == "incidentClosed"
		IncidentClosed string

		// ManuallyTriggered == "manuallyTriggered"
		ManuallyTriggered string

		// IncidentFilter == "incidentFilter"
		IncidentFilter string
	}

	// HookRunUpdateStatus contains the acceptable values for the
	// HookRun.UpdateStatus field.
	HookRunUpdateStatus struct {

		// Todo == "todo"
		Todo string

		// Success == "success"
		Success string

		// Failed == "failed"
		Failed string
	}

	// HookRunStatus contains the acceptable values for the
	// HookRun.Status field.
	HookRunStatus struct {

		// Todo == "todo"
		Todo string

		// Success == "success"
		Success string

		// Failed == "failed"
		Failed string
	}

	// IncidentStatus contains the acceptable values for the
	// Incident.Status field.
	IncidentStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentPreviewIncidentType contains the acceptable values for the
	// IncidentPreview.IncidentType field.
	IncidentPreviewIncidentType struct {

		// Internal == "internal"
		Internal string

		// Private == "private"
		Private string
	}

	// IncidentPreviewStatus contains the acceptable values for the
	// IncidentPreview.Status field.
	IncidentPreviewStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentPreviewsQueryOrderDirection contains the acceptable values for the
	// IncidentPreviewsQuery.OrderDirection field.
	IncidentPreviewsQueryOrderDirection struct {

		// ASC == "ASC"
		ASC string

		// DESC == "DESC"
		DESC string
	}

	// IncidentPreviewsQueryOrderField contains the acceptable values for the
	// IncidentPreviewsQuery.OrderField field.
	IncidentPreviewsQueryOrderField struct {

		// IncidentID == "incidentID"
		IncidentID string

		// CreatedTime == "createdTime"
		CreatedTime string

		// ModifiedTime == "modifiedTime"
		ModifiedTime string

		// Title == "title"
		Title string

		// Status == "status"
		Status string

		// Severity == "severity"
		Severity string

		// Prefix == "prefix"
		Prefix string

		// IsDrill == "isDrill"
		IsDrill string

		// IncidentStart == "incidentStart"
		IncidentStart string

		// IncidentEnd == "incidentEnd"
		IncidentEnd string

		// ClosedTime == "closedTime"
		ClosedTime string
	}

	// IncidentsQueryIncludeStatuses contains the acceptable values for the
	// IncidentsQuery.IncludeStatuses field.
	IncidentsQueryIncludeStatuses struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentsQueryExcludeStatuses contains the acceptable values for the
	// IncidentsQuery.ExcludeStatuses field.
	IncidentsQueryExcludeStatuses struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentsQueryOrderDirection contains the acceptable values for the
	// IncidentsQuery.OrderDirection field.
	IncidentsQueryOrderDirection struct {

		// ASC == "ASC"
		ASC string

		// DESC == "DESC"
		DESC string
	}

	// TaskStatus contains the acceptable values for the
	// Task.Status field.
	TaskStatus struct {

		// Todo == "todo"
		Todo string

		// Progress == "progress"
		Progress string

		// Done == "done"
		Done string
	}

	// UnassignRoleRequestRole contains the acceptable values for the
	// UnassignRoleRequest.Role field.
	UnassignRoleRequestRole struct {

		// Commander == "commander"
		Commander string

		// Investigator == "investigator"
		Investigator string

		// Observer == "observer"
		Observer string
	}

	// UpdateActivityRelevanceRequestRelevance contains the acceptable values for the
	// UpdateActivityRelevanceRequest.Relevance field.
	UpdateActivityRelevanceRequestRelevance struct {

		// Automatic == "automatic"
		Automatic string

		// Archive == "archive"
		Archive string

		// Low == "low"
		Low string

		// Normal == "normal"
		Normal string

		// High == "high"
		High string
	}

	// UpdateIncidentEventTimeRequestActivityItemKind contains the acceptable values for the
	// UpdateIncidentEventTimeRequest.ActivityItemKind field.
	UpdateIncidentEventTimeRequestActivityItemKind struct {

		// IncidentEnd == "incidentEnd"
		IncidentEnd string

		// IncidentStart == "incidentStart"
		IncidentStart string
	}

	// UpdateIncidentEventTimeRequestEventName contains the acceptable values for the
	// UpdateIncidentEventTimeRequest.EventName field.
	UpdateIncidentEventTimeRequestEventName struct {

		// IncidentEnd == "incidentEnd"
		IncidentEnd string

		// IncidentStart == "incidentStart"
		IncidentStart string
	}

	// UpdateStatusRequestStatus contains the acceptable values for the
	// UpdateStatusRequest.Status field.
	UpdateStatusRequestStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// UpdateTaskStatusRequestStatus contains the acceptable values for the
	// UpdateTaskStatusRequest.Status field.
	UpdateTaskStatusRequestStatus struct {

		// Todo == "todo"
		Todo string

		// Progress == "progress"
		Progress string

		// Done == "done"
		Done string
	}
}

func init() {

	Options.ActivityItemActivityKind.IncidentUpdated = "incidentUpdated"

	Options.ActivityItemActivityKind.IncidentTitleChanged = "incidentTitleChanged"

	Options.ActivityItemActivityKind.IncidentStatusChanged = "incidentStatusChanged"

	Options.ActivityItemActivityKind.IncidentSeverityChanged = "incidentSeverityChanged"

	Options.ActivityItemActivityKind.IncidentCreated = "incidentCreated"

	Options.ActivityItemActivityKind.IncidentDeleted = "incidentDeleted"

	Options.ActivityItemActivityKind.IncidentClosed = "incidentClosed"

	Options.ActivityItemActivityKind.RoleAssigned = "roleAssigned"

	Options.ActivityItemActivityKind.RoleUnassigned = "roleUnassigned"

	Options.ActivityItemActivityKind.ActionRun = "actionRun"

	Options.ActivityItemActivityKind.UserNote = "userNote"

	Options.ActivityItemActivityKind.DataQuery = "dataQuery"

	Options.ActivityItemActivityKind.HookRunMetadata = "hookRunMetadata"

	Options.ActivityItemActivityKind.TaskAdded = "taskAdded"

	Options.ActivityItemActivityKind.TaskUpdated = "taskUpdated"

	Options.ActivityItemActivityKind.TaskCompleted = "taskCompleted"

	Options.ActivityItemActivityKind.TaskDeleted = "taskDeleted"

	Options.ActivityItemActivityKind.MessageReaction = "messageReaction"

	Options.ActivityItemActivityKind.ContextAttached = "contextAttached"

	Options.ActivityItemActivityKind.IncidentIsDrillChanged = "incidentIsDrillChanged"

	Options.ActivityItemActivityKind.IncidentStart = "incidentStart"

	Options.ActivityItemActivityKind.IncidentEnd = "incidentEnd"

	Options.ActivityItemActivityKind.IncidentSummary = "incidentSummary"

	Options.ActivityItemActivityKind.LabelAdded = "labelAdded"

	Options.ActivityItemActivityKind.LabelRemoved = "labelRemoved"

	Options.ActivityItemActivityKind.SiftResult = "siftResult"

	Options.ActivityItemRelevance.Automatic = "automatic"

	Options.ActivityItemRelevance.Archive = "archive"

	Options.ActivityItemRelevance.Low = "low"

	Options.ActivityItemRelevance.Normal = "normal"

	Options.ActivityItemRelevance.High = "high"

	Options.ActivityQueryOrderDirection.ASC = "ASC"

	Options.ActivityQueryOrderDirection.DESC = "DESC"

	Options.AddActivityRequestActivityKind.UserNote = "userNote"

	Options.AssignRoleRequestRole.Commander = "commander"

	Options.AssignRoleRequestRole.Investigator = "investigator"

	Options.AssignRoleRequestRole.Observer = "observer"

	Options.AttachmentFileType.File = "file"

	Options.AttachmentFileType.Video = "video"

	Options.AttachmentFileType.Image = "image"

	Options.AttachmentFileType.Audio = "audio"

	Options.AttachmentFileType.Screenshare = "screenshare"

	Options.AttachmentDisplayType.List = "list"

	Options.AttachmentDisplayType.Embed = "embed"

	Options.CreateIncidentRequestStatus.Active = "active"

	Options.CreateIncidentRequestStatus.Resolved = "resolved"

	Options.CustomMetadataFieldType.String = "string"

	Options.CustomMetadataFieldType.SingleSelect = "single-select"

	Options.CustomMetadataFieldType.MultiSelect = "multi-select"

	Options.CustomMetadataFieldType.Bool = "bool"

	Options.CustomMetadataFieldType.Number = "number"

	Options.CustomMetadataFieldType.Date = "date"

	Options.CustomMetadataFieldDomainName.Labels = "labels"

	Options.CustomMetadataFieldDomainName.Incident = "incident"

	Options.EnableHookRequestEventName.IncidentCreated = "incidentCreated"

	Options.EnableHookRequestEventName.IncidentDeleted = "incidentDeleted"

	Options.EnableHookRequestEventName.IncidentUpdated = "incidentUpdated"

	Options.EnableHookRequestEventName.IncidentClosed = "incidentClosed"

	Options.EnableHookRequestEventName.ManuallyTriggered = "manuallyTriggered"

	Options.EnableHookRequestEventName.IncidentFilter = "incidentFilter"

	Options.FieldType.String = "string"

	Options.FieldType.StringGrafanaAPIKeyViewer = "string[grafana.apiKey:viewer]"

	Options.FieldType.StringGrafanaAPIKeyAdmin = "string[grafana.apiKey:admin]"

	Options.FieldType.Bool = "bool"

	Options.GetFieldValuesRequestTargetKind.Incident = "incident"

	Options.HookRunEventName.IncidentCreated = "incidentCreated"

	Options.HookRunEventName.IncidentDeleted = "incidentDeleted"

	Options.HookRunEventName.IncidentUpdated = "incidentUpdated"

	Options.HookRunEventName.IncidentClosed = "incidentClosed"

	Options.HookRunEventName.ManuallyTriggered = "manuallyTriggered"

	Options.HookRunEventName.IncidentFilter = "incidentFilter"

	Options.HookRunUpdateStatus.Todo = "todo"

	Options.HookRunUpdateStatus.Success = "success"

	Options.HookRunUpdateStatus.Failed = "failed"

	Options.HookRunStatus.Todo = "todo"

	Options.HookRunStatus.Success = "success"

	Options.HookRunStatus.Failed = "failed"

	Options.IncidentStatus.Active = "active"

	Options.IncidentStatus.Resolved = "resolved"

	Options.IncidentPreviewIncidentType.Internal = "internal"

	Options.IncidentPreviewIncidentType.Private = "private"

	Options.IncidentPreviewStatus.Active = "active"

	Options.IncidentPreviewStatus.Resolved = "resolved"

	Options.IncidentPreviewsQueryOrderDirection.ASC = "ASC"

	Options.IncidentPreviewsQueryOrderDirection.DESC = "DESC"

	Options.IncidentPreviewsQueryOrderField.IncidentID = "incidentID"

	Options.IncidentPreviewsQueryOrderField.CreatedTime = "createdTime"

	Options.IncidentPreviewsQueryOrderField.ModifiedTime = "modifiedTime"

	Options.IncidentPreviewsQueryOrderField.Title = "title"

	Options.IncidentPreviewsQueryOrderField.Status = "status"

	Options.IncidentPreviewsQueryOrderField.Severity = "severity"

	Options.IncidentPreviewsQueryOrderField.Prefix = "prefix"

	Options.IncidentPreviewsQueryOrderField.IsDrill = "isDrill"

	Options.IncidentPreviewsQueryOrderField.IncidentStart = "incidentStart"

	Options.IncidentPreviewsQueryOrderField.IncidentEnd = "incidentEnd"

	Options.IncidentPreviewsQueryOrderField.ClosedTime = "closedTime"

	Options.IncidentsQueryIncludeStatuses.Active = "active"

	Options.IncidentsQueryIncludeStatuses.Resolved = "resolved"

	Options.IncidentsQueryExcludeStatuses.Active = "active"

	Options.IncidentsQueryExcludeStatuses.Resolved = "resolved"

	Options.IncidentsQueryOrderDirection.ASC = "ASC"

	Options.IncidentsQueryOrderDirection.DESC = "DESC"

	Options.TaskStatus.Todo = "todo"

	Options.TaskStatus.Progress = "progress"

	Options.TaskStatus.Done = "done"

	Options.UnassignRoleRequestRole.Commander = "commander"

	Options.UnassignRoleRequestRole.Investigator = "investigator"

	Options.UnassignRoleRequestRole.Observer = "observer"

	Options.UpdateActivityRelevanceRequestRelevance.Automatic = "automatic"

	Options.UpdateActivityRelevanceRequestRelevance.Archive = "archive"

	Options.UpdateActivityRelevanceRequestRelevance.Low = "low"

	Options.UpdateActivityRelevanceRequestRelevance.Normal = "normal"

	Options.UpdateActivityRelevanceRequestRelevance.High = "high"

	Options.UpdateIncidentEventTimeRequestActivityItemKind.IncidentEnd = "incidentEnd"

	Options.UpdateIncidentEventTimeRequestActivityItemKind.IncidentStart = "incidentStart"

	Options.UpdateIncidentEventTimeRequestEventName.IncidentEnd = "incidentEnd"

	Options.UpdateIncidentEventTimeRequestEventName.IncidentStart = "incidentStart"

	Options.UpdateStatusRequestStatus.Active = "active"

	Options.UpdateStatusRequestStatus.Resolved = "resolved"

	Options.UpdateTaskStatusRequestStatus.Todo = "todo"

	Options.UpdateTaskStatusRequestStatus.Progress = "progress"

	Options.UpdateTaskStatusRequestStatus.Done = "done"

}
